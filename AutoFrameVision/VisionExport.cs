//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 11.0
//

using HalconDotNet;

public partial class HDevelopExport
{
#if !NO_EXPORT_APP_MAIN
  public HDevelopExport()
  {
    // Default settings used in HDevelop 
    HOperatorSet.SetSystem("width", 512);
    HOperatorSet.SetSystem("height", 512);
    action();
  }
#endif

    public void HDevelopStop()
    {
    }

    // Procedures 
    // External procedures 
    // Chapter: Matching / Shape-Based
    // Short Description: Display the results of Shape-Based Matching.
    public void dev_display_shape_matching_results(HTuple hv_ModelID, HTuple hv_Color,
        HTuple hv_Row, HTuple hv_Column, HTuple hv_Angle, HTuple hv_ScaleR, HTuple hv_ScaleC,
        HTuple hv_Model)
    {


        // Local iconic variables 

        HObject ho_ModelContours = null, ho_ContoursAffinTrans = null;


        // Local control variables 

        HTuple hv_NumMatches = null, hv_Index = new HTuple();
        HTuple hv_Match = new HTuple(), hv_HomMat2DIdentity = new HTuple();
        HTuple hv_HomMat2DScale = new HTuple(), hv_HomMat2DRotate = new HTuple();
        HTuple hv_HomMat2DTranslate = new HTuple();

        HTuple hv_Model_COPY_INP_TMP = hv_Model.Clone();
        HTuple hv_ScaleC_COPY_INP_TMP = hv_ScaleC.Clone();
        HTuple hv_ScaleR_COPY_INP_TMP = hv_ScaleR.Clone();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ModelContours);
        HOperatorSet.GenEmptyObj(out ho_ContoursAffinTrans);

        try
        {
            //This procedure displays the results of Shape-Based Matching.
            //
            hv_NumMatches = new HTuple(hv_Row.TupleLength());
            if ((int)(new HTuple(hv_NumMatches.TupleGreater(0))) != 0)
            {
                if ((int)(new HTuple((new HTuple(hv_ScaleR_COPY_INP_TMP.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    HOperatorSet.TupleGenConst(hv_NumMatches, hv_ScaleR_COPY_INP_TMP, out hv_ScaleR_COPY_INP_TMP);
                }
                if ((int)(new HTuple((new HTuple(hv_ScaleC_COPY_INP_TMP.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    HOperatorSet.TupleGenConst(hv_NumMatches, hv_ScaleC_COPY_INP_TMP, out hv_ScaleC_COPY_INP_TMP);
                }
                if ((int)(new HTuple((new HTuple(hv_Model_COPY_INP_TMP.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    HOperatorSet.TupleGenConst(hv_NumMatches, 0, out hv_Model_COPY_INP_TMP);
                }
                else if ((int)(new HTuple((new HTuple(hv_Model_COPY_INP_TMP.TupleLength()
                    )).TupleEqual(1))) != 0)
                {
                    HOperatorSet.TupleGenConst(hv_NumMatches, hv_Model_COPY_INP_TMP, out hv_Model_COPY_INP_TMP);
                }
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ModelID.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    ho_ModelContours.Dispose();
                    HOperatorSet.GetShapeModelContours(out ho_ModelContours, hv_ModelID.TupleSelect(
                        hv_Index), 1);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Color.TupleSelect(
                            hv_Index % (new HTuple(hv_Color.TupleLength()))));
                    }
                    HTuple end_val18 = hv_NumMatches - 1;
                    HTuple step_val18 = 1;
                    for (hv_Match = 0; hv_Match.Continue(end_val18, step_val18); hv_Match = hv_Match.TupleAdd(step_val18))
                    {
                        if ((int)(new HTuple(hv_Index.TupleEqual(hv_Model_COPY_INP_TMP.TupleSelect(
                            hv_Match)))) != 0)
                        {
                            HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                            HOperatorSet.HomMat2dScale(hv_HomMat2DIdentity, hv_ScaleR_COPY_INP_TMP.TupleSelect(
                                hv_Match), hv_ScaleC_COPY_INP_TMP.TupleSelect(hv_Match), 0, 0,
                                out hv_HomMat2DScale);
                            HOperatorSet.HomMat2dRotate(hv_HomMat2DScale, hv_Angle.TupleSelect(
                                hv_Match), 0, 0, out hv_HomMat2DRotate);
                            HOperatorSet.HomMat2dTranslate(hv_HomMat2DRotate, hv_Row.TupleSelect(
                                hv_Match), hv_Column.TupleSelect(hv_Match), out hv_HomMat2DTranslate);
                            ho_ContoursAffinTrans.Dispose();
                            HOperatorSet.AffineTransContourXld(ho_ModelContours, out ho_ContoursAffinTrans,
                                hv_HomMat2DTranslate);
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ContoursAffinTrans, HDevWindowStack.GetActive()
                                    );
                            }
                        }
                    }
                }
            }
            ho_ModelContours.Dispose();
            ho_ContoursAffinTrans.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ModelContours.Dispose();
            ho_ContoursAffinTrans.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Graphics / Text
    // Short Description: This procedure writes a text message.
    public void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
        HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
    {


        // Local control variables 

        HTuple hv_Red = null, hv_Green = null, hv_Blue = null;
        HTuple hv_Row1Part = null, hv_Column1Part = null, hv_Row2Part = null;
        HTuple hv_Column2Part = null, hv_RowWin = null, hv_ColumnWin = null;
        HTuple hv_WidthWin = null, hv_HeightWin = null, hv_MaxAscent = null;
        HTuple hv_MaxDescent = null, hv_MaxWidth = null, hv_MaxHeight = null;
        HTuple hv_R1 = new HTuple(), hv_C1 = new HTuple(), hv_FactorRow = new HTuple();
        HTuple hv_FactorColumn = new HTuple(), hv_Width = new HTuple();
        HTuple hv_Index = new HTuple(), hv_Ascent = new HTuple();
        HTuple hv_Descent = new HTuple(), hv_W = new HTuple();
        HTuple hv_H = new HTuple(), hv_FrameHeight = new HTuple();
        HTuple hv_FrameWidth = new HTuple(), hv_R2 = new HTuple();
        HTuple hv_C2 = new HTuple(), hv_DrawMode = new HTuple();
        HTuple hv_Exception = new HTuple(), hv_CurrentColor = new HTuple();

        HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();
        HTuple hv_Column_COPY_INP_TMP = hv_Column.Clone();
        HTuple hv_Row_COPY_INP_TMP = hv_Row.Clone();
        HTuple hv_String_COPY_INP_TMP = hv_String.Clone();

        // Initialize local and output iconic variables 

        //This procedure displays text in a graphics window.
        //
        //Input parameters:
        //WindowHandle: The WindowHandle of the graphics window, where
        //   the message should be displayed
        //String: A tuple of strings containing the text message to be displayed
        //CoordSystem: If set to 'window', the text position is given
        //   with respect to the window coordinate system.
        //   If set to 'image', image coordinates are used.
        //   (This may be useful in zoomed images.)
        //Row: The row coordinate of the desired text position
        //   If set to -1, a default value of 12 is used.
        //Column: The column coordinate of the desired text position
        //   If set to -1, a default value of 12 is used.
        //Color: defines the color of the text as string.
        //   If set to [], '' or 'auto' the currently set color is used.
        //   If a tuple of strings is passed, the colors are used cyclically
        //   for each new textline.
        //Box: If set to 'true', the text is written within a white box.
        //
        //prepare window
        HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
        HOperatorSet.GetPart(hv_WindowHandle, out hv_Row1Part, out hv_Column1Part, out hv_Row2Part,
            out hv_Column2Part);
        HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowWin, out hv_ColumnWin,
            out hv_WidthWin, out hv_HeightWin);
        HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_HeightWin - 1, hv_WidthWin - 1);
        //
        //default settings
        if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
        {
            hv_Row_COPY_INP_TMP = 12;
        }
        if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
        {
            hv_Column_COPY_INP_TMP = 12;
        }
        if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
        {
            hv_Color_COPY_INP_TMP = "";
        }
        //
        hv_String_COPY_INP_TMP = ((("" + hv_String_COPY_INP_TMP) + "")).TupleSplit("\n");
        //
        //Estimate extentions of text depending on font size.
        HOperatorSet.GetFontExtents(hv_WindowHandle, out hv_MaxAscent, out hv_MaxDescent,
            out hv_MaxWidth, out hv_MaxHeight);
        if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
        {
            hv_R1 = hv_Row_COPY_INP_TMP.Clone();
            hv_C1 = hv_Column_COPY_INP_TMP.Clone();
        }
        else
        {
            //transform image to window coordinates
            hv_FactorRow = (1.0 * hv_HeightWin) / ((hv_Row2Part - hv_Row1Part) + 1);
            hv_FactorColumn = (1.0 * hv_WidthWin) / ((hv_Column2Part - hv_Column1Part) + 1);
            hv_R1 = ((hv_Row_COPY_INP_TMP - hv_Row1Part) + 0.5) * hv_FactorRow;
            hv_C1 = ((hv_Column_COPY_INP_TMP - hv_Column1Part) + 0.5) * hv_FactorColumn;
        }
        //
        //display text box depending on text size
        if ((int)(new HTuple(hv_Box.TupleEqual("true"))) != 0)
        {
            //calculate box extents
            hv_String_COPY_INP_TMP = (" " + hv_String_COPY_INP_TMP) + " ";
            hv_Width = new HTuple();
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
                    hv_Index), out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
                hv_Width = hv_Width.TupleConcat(hv_W);
            }
            hv_FrameHeight = hv_MaxHeight * (new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                ));
            hv_FrameWidth = (((new HTuple(0)).TupleConcat(hv_Width))).TupleMax();
            hv_R2 = hv_R1 + hv_FrameHeight;
            hv_C2 = hv_C1 + hv_FrameWidth;
            //display rectangles
            HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
            HOperatorSet.SetDraw(hv_WindowHandle, "fill");
            HOperatorSet.SetColor(hv_WindowHandle, "light gray");
            HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1 + 3, hv_C1 + 3, hv_R2 + 3, hv_C2 + 3);
            HOperatorSet.SetColor(hv_WindowHandle, "white");
            HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
            HOperatorSet.SetDraw(hv_WindowHandle, hv_DrawMode);
        }
        else if ((int)(new HTuple(hv_Box.TupleNotEqual("false"))) != 0)
        {
            hv_Exception = "Wrong value of control parameter Box";
            throw new HalconException(hv_Exception);
        }
        //Write text.
        for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
            )) - 1); hv_Index = (int)hv_Index + 1)
        {
            hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_Index % (new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
                )));
            if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
                "auto")))) != 0)
            {
                HOperatorSet.SetColor(hv_WindowHandle, hv_CurrentColor);
            }
            else
            {
                HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
            }
            hv_Row_COPY_INP_TMP = hv_R1 + (hv_MaxHeight * hv_Index);
            HOperatorSet.SetTposition(hv_WindowHandle, hv_Row_COPY_INP_TMP, hv_C1);
            HOperatorSet.WriteString(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
                hv_Index));
        }
        //reset changed window settings
        HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
        HOperatorSet.SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part,
            hv_Column2Part);

        return;
    }

    // Short Description: 读取模板得到模板中心点和角度。
    public void InitTemplete(HTuple hv_Directory, out HTuple hv_ModelId, out HTuple hv_ModelData)
    {


        // Local iconic variables 

        HObject ho_ImageModel;


        // Local control variables 

        HTuple hv_WindowHandle = null, hv_ModelRow = null;
        HTuple hv_ModelColumn = null, hv_ModelAngle = null, hv_ModelScore = null;

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ImageModel);

        try
        {

            hv_ModelData = new HTuple();
            ho_ImageModel.Dispose();
            HOperatorSet.ReadImage(out ho_ImageModel, hv_Directory + "/Model.bmp");
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ImageModel, HDevWindowStack.GetActive());
            }
            hv_WindowHandle = -1;
            if (HDevWindowStack.IsOpen())
            {
                hv_WindowHandle = HDevWindowStack.GetActive();
            }

            //tuple_length (WindowHandle, num)
            HOperatorSet.ReadShapeModel(hv_Directory + "/Model.shm", out hv_ModelId);
            //模板图片查找模板位置,不需要使用变形模板
            HOperatorSet.FindShapeModel(ho_ImageModel, hv_ModelId, (new HTuple(0)).TupleRad()
                , (new HTuple(360)).TupleRad(), 0.6, 1, 0.5, "least_squares", (new HTuple(5)).TupleConcat(
                1), 0.75, out hv_ModelRow, out hv_ModelColumn, out hv_ModelAngle, out hv_ModelScore);
            //Matching 01: transform the model contours into the detected positions
            if ((int)(new HTuple((new HTuple(hv_ModelScore.TupleLength())).TupleGreater(
                0))) != 0)
            {
                //存储模板位置信息
                HOperatorSet.TupleConcat(hv_ModelData, hv_ModelRow, out hv_ModelData);
                HOperatorSet.TupleConcat(hv_ModelData, hv_ModelColumn, out hv_ModelData);
                HOperatorSet.TupleConcat(hv_ModelData, hv_ModelAngle, out hv_ModelData);

                dev_display_shape_matching_results(hv_ModelId, "red", hv_ModelRow, hv_ModelColumn,
                    hv_ModelAngle, 1, 1, 0);
                dev_disp_message("Model Score is " + hv_ModelScore, "window", 20, 20, "green",
                    "false");
            }
            else
            {

                dev_disp_message("Model find fail !", "window", 20, 20, "red", "true");

            }
            ho_ImageModel.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ImageModel.Dispose();

            throw HDevExpDefaultException;
        }
    }
    public void CalcRotateCenter(HTuple hv_Row1, HTuple hv_Col1, HTuple hv_Row2, HTuple hv_Col2,
HTuple hv_Angle, out HTuple hv_RowCenter, out HTuple hv_ColCenter)
    {


        // Local iconic variables 


        // Local control variables 

        HTuple hv_angleTest = null, hv_flag = null;
        HTuple hv_mat0 = null, hv_mat1 = null, hv_RowTrans1 = null;
        HTuple hv_ColTrans1 = null, hv_mat2 = null, hv_RowTrans2 = null;
        HTuple hv_ColTrans2 = null, hv_IsOverlapping = null;

        // Initialize local and output iconic variables 

        try
        {
            //输入两个点及两点之间的旋转角度，求出旋转中心

            //求出等腰三角形的底角A
            hv_angleTest = 180 - (hv_Angle.TupleAbs());
            hv_angleTest = ((hv_angleTest / 2)).TupleRad();

            //确定变换旋转矩阵的旋转方向
            hv_flag = 1;
            if ((int)(new HTuple(hv_Angle.TupleLess(0))) != 0)
            {
                hv_flag = -1;
            }

            //gen_cross_contour_xld (Cross, Row1, Col1, 60, 0.785398)
            //gen_cross_contour_xld (Cross, Row2, Col2, 60, 0.785398)
            //第二点以第一点为中心点旋转A度
            HOperatorSet.HomMat2dIdentity(out hv_mat0);
            HOperatorSet.HomMat2dRotate(hv_mat0, hv_flag * hv_angleTest, hv_Row1, hv_Col1,
                out hv_mat1);

            HOperatorSet.AffineTransPoint2d(hv_mat1, hv_Row2, hv_Col2, out hv_RowTrans1,
                out hv_ColTrans1);

            //gen_cross_contour_xld (Cross1, RowTrans1, ColTrans1, 60, 0.785398)
            //distance_pp (Row1, Col1, Row2, Col2, Distance1)
            //distance_pp (Row1, Col1, RowTrans1, ColTrans1, Distance2)

            //让第一点以第二点反向旋转A度
            HOperatorSet.HomMat2dRotate(hv_mat0, (-hv_flag) * hv_angleTest, hv_Row2, hv_Col2,
                out hv_mat2);
            HOperatorSet.AffineTransPoint2d(hv_mat2, hv_Row1, hv_Col1, out hv_RowTrans2,
                out hv_ColTrans2);

            //gen_cross_contour_xld (Cross1, RowTrans2, ColTrans2, 60, 0.785398)
            //distance_pp (Row2, Col2, Row1, Col1, Distance3)
            //distance_pp (Row2, Col2, RowTrans2, ColTrans2, Distance4)

            //求出两线的交点，即为旋转中心
            HOperatorSet.IntersectionLines(hv_Row1, hv_Col1, hv_RowTrans1, hv_ColTrans1,
                hv_Row2, hv_Col2, hv_RowTrans2, hv_ColTrans2, out hv_RowCenter, out hv_ColCenter,
                out hv_IsOverlapping);

            //gen_cross_contour_xld (Cross2, Row, Column, 60, 0.785398)
            //gen_region_line (RegionLine1, Row, Column, Row1, Col1)
            //gen_region_line (RegionLine1, Row, Column, Row2, Col2)










            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            throw HDevExpDefaultException;
        }
    }
    public void CalcRotatePoint(HTuple hv_RowCenter, HTuple hv_ColCenter, HTuple hv_RowOld,
        HTuple hv_ColOld, HTuple hv_Angle, out HTuple hv_RowNew, out HTuple hv_ColNew)
    {


        // Local control variables 

        HTuple hv_mat0 = null, hv_mat1 = null;

        // Initialize local and output iconic variables 




        //已知旋转中心点，将要被旋转的点和需要旋转的角度，计算旋转后的点的位置
        HOperatorSet.HomMat2dIdentity(out hv_mat0);
        HOperatorSet.HomMat2dRotate(hv_mat0, hv_Angle.TupleRad(), hv_RowCenter, hv_ColCenter,
            out hv_mat1);
        HOperatorSet.AffineTransPoint2d(hv_mat1, hv_RowOld, hv_ColOld, out hv_RowNew,
            out hv_ColNew);




    }
    // Short Description: 从ROI文件中读取旋转矩形参数
    public void ReadRoiRectangle2(HTuple hv_FileName, out HTuple hv_TupleData)
    {


        // Local iconic variables 


        // Local control variables 

        HTuple hv_FileHandle = null, hv_IsEOF = null;
        HTuple hv_x = null, hv_y = null, hv_strText = new HTuple();
        HTuple hv_strOp = new HTuple(), hv_strData = new HTuple();
        HTuple hv_len1 = new HTuple(), hv_len2 = new HTuple();
        HTuple hv_row = new HTuple(), hv_col = new HTuple(), hv_phi = new HTuple();

        // Initialize local and output iconic variables 

        try
        {

            HOperatorSet.OpenFile(hv_FileName, "input", out hv_FileHandle);
            hv_IsEOF = 0;
            hv_x = 0;
            hv_y = 10;
            hv_TupleData = new HTuple();
            while ((int)(new HTuple(hv_IsEOF.TupleEqual(0))) != 0)
            {
                HOperatorSet.FreadString(hv_FileHandle, out hv_strText, out hv_IsEOF);
                if ((int)(new HTuple(hv_strText.TupleEqual("<roi"))) != 0)
                {
                    while ((int)(new HTuple(hv_IsEOF.TupleEqual(0))) != 0)
                    {
                        HOperatorSet.FreadString(hv_FileHandle, out hv_strText, out hv_IsEOF);
                        //disp_message (Window, strText, 'window', x, y, 'red', 'false')
                        hv_x = hv_x + 15;
                        if ((int)(new HTuple(hv_strText.TupleEqual("<rect2"))) != 0)
                        {
                            HOperatorSet.FreadString(hv_FileHandle, out hv_strOp, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_strData, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_len1, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_len2, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_row, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_col, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_phi, out hv_IsEOF);
                            //disp_message (Window, strOp + len1+len2+row+col+phi, 'window', x, y, 'red', 'false')
                            hv_x = hv_x + 15;
                            HOperatorSet.TupleRegexpMatch(hv_row, "=\"(.*)\"", out hv_row);
                            HOperatorSet.TupleNumber(hv_row, out hv_row);
                            HOperatorSet.TupleRegexpMatch(hv_col, "=\"(.*)\"", out hv_col);
                            HOperatorSet.TupleNumber(hv_col, out hv_col);
                            HOperatorSet.TupleRegexpMatch(hv_phi, "=\"(.*)\"", out hv_phi);
                            HOperatorSet.TupleNumber(hv_phi, out hv_phi);
                            HOperatorSet.TupleRegexpMatch(hv_len1, "=\"(.*)\"", out hv_len1);
                            HOperatorSet.TupleNumber(hv_len1, out hv_len1);
                            HOperatorSet.TupleRegexpMatch(hv_len2, "=\"(.*)\"", out hv_len2);
                            HOperatorSet.TupleNumber(hv_len2, out hv_len2);

                            HOperatorSet.TupleConcat(hv_TupleData, hv_row, out hv_TupleData);
                            HOperatorSet.TupleConcat(hv_TupleData, hv_col, out hv_TupleData);
                            HOperatorSet.TupleConcat(hv_TupleData, hv_phi, out hv_TupleData);
                            HOperatorSet.TupleConcat(hv_TupleData, hv_len1, out hv_TupleData);
                            HOperatorSet.TupleConcat(hv_TupleData, hv_len2, out hv_TupleData);

                            //tuple_regexp_match (strOp, '="(.*)"', strOp)
                            //if (strOp == 'none')
                            //gen_rectangle2 (Region, row, col, rad(phi), len1, len2)
                            //else
                            //gen_rectangle2 (Rectangle2, row, col, rad(phi), len1, len2)
                            //if (strOp == 'union')
                            //union2 (Region, Rectangle2, Region)
                            //elseif (strOp == 'intersection')
                            //intersection (Region, Rectangle2, Region)
                            //elseif (strOp == 'difference')
                            //difference (Region, Rectangle2, Region)
                            //else
                            //disp_message (Window, strOp + 'not support!', 'window', x, y, 'red', 'false')
                            //x := x+15
                            //endif
                            //endif
                        }
                    }
                }
            }
            HOperatorSet.CloseFile(hv_FileHandle);

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 得到转换后的ROI数据。
    public void TranslateRoi(HTuple hv_FixTool, HTuple hv_TupleDataIn, out HTuple hv_TupleDataOut)
    {


        // Local iconic variables 


        // Local control variables 

        HTuple hv_Sx = null, hv_Sy = null, hv_Phi = null;
        HTuple hv_Theta = null, hv_Tx = null, hv_Ty = null, hv_Number = null;
        HTuple hv_row = new HTuple(), hv_col = new HTuple();

        // Initialize local and output iconic variables 

        try
        {
            HOperatorSet.HomMat2dToAffinePar(hv_FixTool, out hv_Sx, out hv_Sy, out hv_Phi,
                out hv_Theta, out hv_Tx, out hv_Ty);
            HOperatorSet.TupleLength(hv_TupleDataIn, out hv_Number);
            hv_TupleDataOut = new HTuple();
            //旋转矩形
            if ((int)(new HTuple(hv_Number.TupleEqual(5))) != 0)
            {
                HOperatorSet.AffineTransPoint2d(hv_FixTool, hv_TupleDataIn.TupleSelect(0),
                    hv_TupleDataIn.TupleSelect(1), out hv_row, out hv_col);
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[0] = hv_row;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[1] = hv_col;
                //加上模板查找的角度并转换为弧角度
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[2] = (((hv_TupleDataIn.TupleSelect(2))).TupleRad()) + hv_Phi;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[3] = hv_TupleDataIn.TupleSelect(3);
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[4] = hv_TupleDataIn.TupleSelect(4);
                //gen_rectangle2 (Rectangle, TupleDataOut[0], TupleDataOut[1], TupleDataOut[2], TupleDataOut[3], TupleDataOut[4])

                //圆环
            }
            else if ((int)(new HTuple(hv_Number.TupleEqual(6))) != 0)
            {
                HOperatorSet.AffineTransPoint2d(hv_FixTool, hv_TupleDataIn.TupleSelect(0),
                    hv_TupleDataIn.TupleSelect(1), out hv_row, out hv_col);
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[0] = hv_row;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[1] = hv_col;
                //圆没有角度
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[2] = hv_TupleDataIn.TupleSelect(2);
                HOperatorSet.AffineTransPoint2d(hv_FixTool, hv_TupleDataIn.TupleSelect(3),
                    hv_TupleDataIn.TupleSelect(4), out hv_row, out hv_col);
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[3] = hv_row;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[4] = hv_col;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[5] = hv_TupleDataIn.TupleSelect(5);
                //圆弧环
            }
            else if ((int)(new HTuple(hv_Number.TupleEqual(10))) != 0)
            {
                hv_TupleDataOut = hv_TupleDataIn.Clone();
                HOperatorSet.AffineTransPoint2d(hv_FixTool, hv_TupleDataIn.TupleSelect(0),
                    hv_TupleDataIn.TupleSelect(1), out hv_row, out hv_col);
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[0] = hv_row;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[1] = hv_col;
                //圆弧需要计算起始角度
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[3] = (((hv_TupleDataIn.TupleSelect(3))).TupleRad()) + hv_Phi;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[4] = ((hv_TupleDataIn.TupleSelect(4))).TupleRad();

                HOperatorSet.AffineTransPoint2d(hv_FixTool, hv_TupleDataIn.TupleSelect(5),
                    hv_TupleDataIn.TupleSelect(6), out hv_row, out hv_col);
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[5] = hv_row;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[6] = hv_col;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[8] = (((hv_TupleDataIn.TupleSelect(8))).TupleRad()) + hv_Phi;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[9] = ((hv_TupleDataIn.TupleSelect(9))).TupleRad();
                //不支持的格式
            }
            else
            {

            }




            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 通过输入参数寻找区域当中的直线
    public void FindLine(HObject ho_Image, HTuple hv_TupleRectangle2, HTuple hv_NumPoints,
        HTuple hv_RectWidth, HTuple hv_NumDropPoints, HTuple hv_AmpThreshold, HTuple hv_Smooth,
        HTuple hv_Transition, HTuple hv_Select, out HTuple hv_RowBegin, out HTuple hv_ColBegin,
        out HTuple hv_RowEnd, out HTuple hv_ColEnd)
    {


        // Initialize local and output iconic variables 

        //解析ROI数据,转入查找直线函数
        FindLine_Rectangle2(ho_Image, hv_TupleRectangle2.TupleSelect(0), hv_TupleRectangle2.TupleSelect(
            1), hv_TupleRectangle2.TupleSelect(2), hv_TupleRectangle2.TupleSelect(3),
            hv_TupleRectangle2.TupleSelect(4), hv_NumPoints, hv_RectWidth, hv_NumDropPoints,
            hv_AmpThreshold, hv_Smooth, hv_Transition, hv_Select, out hv_RowBegin, out hv_ColBegin,
            out hv_RowEnd, out hv_ColEnd);
    }

    // Short Description: 读取圆roi的中心坐标以及半径。
    public void ReadRoiAnnularCircle(HTuple hv_FileName, out HTuple hv_TupleData)
    {


        // Local iconic variables 


        // Local control variables 

        HTuple hv_FileHandle = null, hv_IsEOF = null;
        HTuple hv_x = null, hv_y = null, hv_strText = new HTuple();
        HTuple hv_strOp = new HTuple(), hv_strData = new HTuple();
        HTuple hv_row = new HTuple(), hv_radius = new HTuple();
        HTuple hv_col = new HTuple();

        // Initialize local and output iconic variables 

        try
        {

            HOperatorSet.OpenFile(hv_FileName, "input", out hv_FileHandle);
            hv_IsEOF = 0;
            hv_x = 0;
            hv_y = 0;
            hv_TupleData = new HTuple();
            while ((int)(new HTuple(hv_IsEOF.TupleEqual(0))) != 0)
            {
                HOperatorSet.FreadString(hv_FileHandle, out hv_strText, out hv_IsEOF);
                //判断是否是ROI区
                if ((int)(new HTuple(hv_strText.TupleEqual("<roi"))) != 0)
                {
                    while ((int)(new HTuple(hv_IsEOF.TupleEqual(0))) != 0)
                    {
                        HOperatorSet.FreadString(hv_FileHandle, out hv_strText, out hv_IsEOF);
                        //disp_message (Window, strText, 'window', x, y, 'red', 'false')
                        //x := x+15
                        //判断是否是圆
                        if ((int)(new HTuple(hv_strText.TupleEqual("<circle"))) != 0)
                        {
                            HOperatorSet.FreadString(hv_FileHandle, out hv_strOp, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_strData, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_row, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_radius, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_col, out hv_IsEOF);
                            //disp_message (Window, strOp + row+radius+col, 'window', x, y, 'red', 'false')
                            //x := x+15
                            HOperatorSet.TupleRegexpMatch(hv_row, "=\"(.*)\"", out hv_row);
                            HOperatorSet.TupleNumber(hv_row, out hv_row);
                            HOperatorSet.TupleRegexpMatch(hv_col, "=\"(.*)\"", out hv_col);
                            HOperatorSet.TupleNumber(hv_col, out hv_col);
                            HOperatorSet.TupleRegexpMatch(hv_radius, "=\"(.*)\"", out hv_radius);
                            HOperatorSet.TupleNumber(hv_radius, out hv_radius);

                            HOperatorSet.TupleRegexpMatch(hv_strOp, "=\"(.*)\"", out hv_strOp);

                            HOperatorSet.TupleConcat(hv_TupleData, hv_row, out hv_TupleData);
                            HOperatorSet.TupleConcat(hv_TupleData, hv_col, out hv_TupleData);
                            HOperatorSet.TupleConcat(hv_TupleData, hv_radius, out hv_TupleData);
                            //if (strOp == 'none')
                            //gen_circle (Region, row, col, radius)
                            //else
                            //gen_circle (Circle, row, col, radius)
                            //if (strOp == 'union')
                            //union2 (Region, Circle, Region)
                            //elseif (strOp == 'intersection')
                            //intersection (Region, Circle, Region)
                            //elseif (strOp == 'difference')
                            //difference (Region, Circle, Region)
                            //else
                            //disp_message (Window, strOp + 'not support!', 'window', x, y, 'red', 'false')
                            //x := x+15
                            //endif
                            //endif
                        }
                    }
                }
            }
            HOperatorSet.CloseFile(hv_FileHandle);

            return;



        }
        catch (HalconException HDevExpDefaultException)
        {

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 通过输入带角度的矩形框寻找中间的直线
    public void FindLine_Rectangle2(HObject ho_Image, HTuple hv_Row, HTuple hv_Col,
        HTuple hv_Phi, HTuple hv_Len1, HTuple hv_Len2, HTuple hv_NumPoints, HTuple hv_RectWidth,
        HTuple hv_NumDropPoints, HTuple hv_AmpThreshold, HTuple hv_Smooth, HTuple hv_Transition,
        HTuple hv_Select, out HTuple hv_RowBegin, out HTuple hv_ColBegin, out HTuple hv_RowEnd,
        out HTuple hv_ColEnd)
    {



        // Local iconic variables 

        HObject ho_cross = null, ho_Contour = null, ho_Line = null;


        // Local control variables 

        HTuple hv_imgWidth = null, hv_imgHeight = null;
        HTuple hv_Rect_Row = null, hv_Rect_Col = null, hv_RowOut = null;
        HTuple hv_ColOut = null, hv_Rect_offset = null, hv_Phi_Tmp = null;
        HTuple hv_Rect_Phi = null, hv_Rect_Len1 = null, hv_Rect_Len2 = null;
        HTuple hv_HomMat2DIdentity = null, hv_HomMat2DTranslate = null;
        HTuple hv_MsrHandle = null, hv_Index = null, hv_WindowHandle = new HTuple();
        HTuple hv_RowMeasure = new HTuple(), hv_num = new HTuple();
        HTuple hv_ColMeasure = new HTuple(), hv_Nr = new HTuple();
        HTuple hv_Nc = new HTuple(), hv_Dist = new HTuple(), hv_rowLine = new HTuple();
        HTuple hv_colLine = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_cross);
        HOperatorSet.GenEmptyObj(out ho_Contour);
        HOperatorSet.GenEmptyObj(out ho_Line);

        hv_RowBegin = new HTuple();
        hv_ColBegin = new HTuple();
        hv_RowEnd = new HTuple();
        hv_ColEnd = new HTuple();
        try
        {


            HOperatorSet.GetImageSize(ho_Image, out hv_imgWidth, out hv_imgHeight);

            hv_Rect_Row = new HTuple();
            hv_Rect_Col = new HTuple();
            hv_RowOut = new HTuple();
            hv_ColOut = new HTuple();

            //计算量测小矩形的座标位置及角度
            hv_Rect_offset = hv_Len1 / hv_NumPoints;
            hv_Phi_Tmp = hv_Phi + ((new HTuple(90)).TupleRad());
            hv_Rect_Row = (hv_Row + (hv_Len2 * (hv_Phi_Tmp.TupleSin()))) - ((hv_Rect_offset * (hv_Phi_Tmp.TupleSin()
                )) / 2);
            hv_Rect_Col = (hv_Col - (hv_Len2 * (hv_Phi_Tmp.TupleCos()))) + ((hv_Rect_offset * (hv_Phi_Tmp.TupleCos()
                )) / 2);
            hv_Rect_Phi = hv_Phi.Clone();
            hv_Rect_Len1 = hv_Len1.Clone();
            hv_Rect_Len2 = hv_RectWidth / 2;

            HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
            HOperatorSet.HomMat2dTranslate(hv_HomMat2DIdentity, (((-hv_Len2) * 2) * (hv_Phi_Tmp.TupleSin()
                )) / hv_NumPoints, ((hv_Len2 * (hv_Phi_Tmp.TupleCos())) * 2) / hv_NumPoints, out hv_HomMat2DTranslate);
            HOperatorSet.GenMeasureRectangle2(hv_Rect_Row, hv_Rect_Col, hv_Rect_Phi, hv_Rect_Len1,
                hv_Rect_Len2, hv_imgWidth, hv_imgHeight, "nearest_neighbor", out hv_MsrHandle);

            HTuple end_val22 = hv_NumPoints - 1;
            HTuple step_val22 = 1;
            for (hv_Index = 0; hv_Index.Continue(end_val22, step_val22); hv_Index = hv_Index.TupleAdd(step_val22))
            {
                //显示当前的量测矩形区域
                if ((int)(1) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "green");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        hv_WindowHandle = HDevWindowStack.GetActive();
                    }
                    HOperatorSet.DispRectangle2(hv_WindowHandle, hv_Rect_Row, hv_Rect_Col,
                        hv_Rect_Phi, hv_Rect_Len1, hv_Rect_Len2);
                }
                //查找边缘点
                FindPoint(ho_Image, hv_MsrHandle, hv_Smooth, hv_AmpThreshold, hv_Transition,
                    hv_Select, out hv_RowMeasure, out hv_ColMeasure);
                HOperatorSet.TupleLength(hv_RowMeasure, out hv_num);
                if ((int)(new HTuple(hv_num.TupleGreater(0))) != 0)
                {
                    HOperatorSet.TupleConcat(hv_RowOut, hv_RowMeasure, out hv_RowOut);
                    HOperatorSet.TupleConcat(hv_ColOut, hv_ColMeasure, out hv_ColOut);
                }
                //旋转及平移量测区区域
                HOperatorSet.AffineTransPixel(hv_HomMat2DTranslate, hv_Rect_Row, hv_Rect_Col,
                    out hv_Rect_Row, out hv_Rect_Col);
                HOperatorSet.TranslateMeasure(hv_MsrHandle, hv_Rect_Row, hv_Rect_Col);
            }
            HOperatorSet.CloseMeasure(hv_MsrHandle);

            //要求获取到的最终的边缘点大于总点数的一半
            if ((int)(new HTuple((new HTuple(hv_RowOut.TupleLength())).TupleGreater(hv_NumPoints / 10))) != 0)
            {
                //绘制每个边缘点
                if ((int)(1) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "blue");
                    }
                    ho_cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_cross, hv_RowOut, hv_ColOut, 10,
                        0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_cross, HDevWindowStack.GetActive());
                    }
                }


                ho_Contour.Dispose();
                HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_RowOut, hv_ColOut);
                HOperatorSet.FitLineContourXld(ho_Contour, "tukey", hv_NumPoints * 0.9, 0,
                    15, 5, out hv_RowBegin, out hv_ColBegin, out hv_RowEnd, out hv_ColEnd,
                    out hv_Nr, out hv_Nc, out hv_Dist);
                //显示查找到的直线
                if ((int)(1) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "red");
                    }
                    hv_rowLine = new HTuple();
                    hv_colLine = new HTuple();
                    HOperatorSet.TupleConcat(hv_rowLine, hv_RowBegin, out hv_rowLine);
                    HOperatorSet.TupleConcat(hv_rowLine, hv_RowEnd, out hv_rowLine);
                    HOperatorSet.TupleConcat(hv_colLine, hv_ColBegin, out hv_colLine);
                    HOperatorSet.TupleConcat(hv_colLine, hv_ColEnd, out hv_colLine);
                    ho_Line.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_Line, hv_rowLine, hv_colLine);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Line, HDevWindowStack.GetActive());
                    }
                }
            }
            else
            {
                hv_RowBegin = new HTuple();
                hv_ColBegin = new HTuple();
                hv_RowEnd = new HTuple();
                hv_ColEnd = new HTuple();
            }
            ho_cross.Dispose();
            ho_Contour.Dispose();
            ho_Line.Dispose();

            return;


        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_cross.Dispose();
            ho_Contour.Dispose();
            ho_Line.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void FindCircle_Circle(HObject ho_Image, HTuple hv_RowCircle, HTuple hv_ColCircle,
        HTuple hv_RadiusCircle, HTuple hv_Length, HTuple hv_PhiStart, HTuple hv_PhiExtent,
        HTuple hv_NumPoints, HTuple hv_NumDropPoints, HTuple hv_AmpThreshold, HTuple hv_Smooth,
        HTuple hv_Transition, HTuple hv_Select, out HTuple hv_Row, out HTuple hv_Col,
        out HTuple hv_Radius)
    {



        // Local iconic variables 

        HObject ho_cross = null, ho_Contour = null, ho_Circle = null;


        // Local control variables 

        HTuple hv_imgWidth = null, hv_imgHeight = null;
        HTuple hv_RowOut = null, hv_ColOut = null, hv_Row_Rect = null;
        HTuple hv_Col_Rect = null, hv_Angle = null, hv_RoiWidth = null;
        HTuple hv_WindowHandle = new HTuple(), hv_direction = new HTuple();
        HTuple hv_HomMat2DIdentity = null, hv_HomMat2DRotate = null;
        HTuple hv_Index = null, hv_MsrHandle = new HTuple(), hv_RowMeasure = new HTuple();
        HTuple hv_num = new HTuple(), hv_ColMeasure = new HTuple();
        HTuple hv_StartPhi = new HTuple(), hv_EndPhi = new HTuple();
        HTuple hv_PointOrder = new HTuple();

        HTuple hv_Length_COPY_INP_TMP = hv_Length.Clone();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_cross);
        HOperatorSet.GenEmptyObj(out ho_Contour);
        HOperatorSet.GenEmptyObj(out ho_Circle);

        hv_Row = new HTuple();
        hv_Col = new HTuple();
        hv_Radius = new HTuple();
        try
        {

            HOperatorSet.GetImageSize(ho_Image, out hv_imgWidth, out hv_imgHeight);
            hv_RowOut = new HTuple();
            hv_ColOut = new HTuple();

            //分割矩形的中心坐标
            hv_Row_Rect = hv_RowCircle - ((hv_PhiStart.TupleSin()) * (hv_RadiusCircle + (hv_Length_COPY_INP_TMP / 2)));
            hv_Col_Rect = hv_ColCircle + ((hv_PhiStart.TupleCos()) * (hv_RadiusCircle + (hv_Length_COPY_INP_TMP / 2)));

            //分割角度
            hv_Angle = hv_PhiExtent / hv_NumPoints;
            hv_RoiWidth = ((hv_Angle.TupleSin()) * (hv_RadiusCircle + (hv_Length_COPY_INP_TMP / 2))) / 2;

            //显示整体的ROI区域
            if (HDevWindowStack.IsOpen())
            {
                //dev_get_window (WindowHandle)
            }
            //disp_circle (WindowHandle, RowCircle, ColCircle, RadiusCircle)
            //disp_circle (WindowHandle, RowCircle, ColCircle, RadiusCircle + Length)

            if ((int)(new HTuple(hv_Length_COPY_INP_TMP.TupleGreater(0))) != 0)
            {
                //由内向外
                hv_direction = 0;
            }
            else
            {
                //由外向内
                hv_direction = (new HTuple(180)).TupleRad();
                hv_Length_COPY_INP_TMP = -hv_Length_COPY_INP_TMP;
            }

            HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
            HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, hv_Angle, hv_RowCircle, hv_ColCircle,
                out hv_HomMat2DRotate);
            HTuple end_val29 = hv_NumPoints - 1;
            HTuple step_val29 = 1;
            for (hv_Index = 0; hv_Index.Continue(end_val29, step_val29); hv_Index = hv_Index.TupleAdd(step_val29))
            {
                //显示当前查找边缘的ROI区
                if ((int)(0) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "green");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        hv_WindowHandle = HDevWindowStack.GetActive();
                    }
                    HOperatorSet.DispRectangle2(hv_WindowHandle, hv_Row_Rect, hv_Col_Rect,
                        (hv_PhiStart + (hv_Index * hv_Angle)) + hv_direction, hv_Length_COPY_INP_TMP / 2,
                        hv_RoiWidth);
                }

                HOperatorSet.GenMeasureRectangle2(hv_Row_Rect, hv_Col_Rect, (hv_PhiStart + (hv_Index * hv_Angle)) + hv_direction,
                    hv_Length_COPY_INP_TMP / 2, hv_RoiWidth, hv_imgWidth, hv_imgHeight, "nearest_neighbor",
                    out hv_MsrHandle);
                //查找边缘点
                FindPoint(ho_Image, hv_MsrHandle, hv_Smooth, hv_AmpThreshold, hv_Transition,
                    hv_Select, out hv_RowMeasure, out hv_ColMeasure);
                HOperatorSet.TupleLength(hv_RowMeasure, out hv_num);
                if ((int)(new HTuple(hv_num.TupleGreater(0))) != 0)
                {
                    HOperatorSet.TupleConcat(hv_RowOut, hv_RowMeasure, out hv_RowOut);
                    HOperatorSet.TupleConcat(hv_ColOut, hv_ColMeasure, out hv_ColOut);
                }
                HOperatorSet.CloseMeasure(hv_MsrHandle);
                //旋转量测区域中心点
                HOperatorSet.AffineTransPixel(hv_HomMat2DRotate, hv_Row_Rect, hv_Col_Rect,
                    out hv_Row_Rect, out hv_Col_Rect);
            }
            //要求获取到的最终的边缘点大于总点数的一半
            if ((int)(new HTuple((new HTuple(hv_RowOut.TupleLength())).TupleGreater(hv_NumPoints / 2))) != 0)
            {
                //显示所有找到的边缘点
                if ((int)(1) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "blue");
                    }
                    ho_cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_cross, hv_RowOut, hv_ColOut, 15,
                        0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_cross, HDevWindowStack.GetActive());
                    }
                }

                ho_Contour.Dispose();
                HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_RowOut, hv_ColOut);
                HOperatorSet.FitCircleContourXld(ho_Contour, "atukey", hv_NumPoints - hv_NumDropPoints,
                    0, 0, 15, 6, out hv_Row, out hv_Col, out hv_Radius, out hv_StartPhi,
                    out hv_EndPhi, out hv_PointOrder);
                //显示找到的圆弧
                if ((int)(1) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "red");
                    }
                    ho_Circle.Dispose();
                    HOperatorSet.GenCircleContourXld(out ho_Circle, hv_Row, hv_Col, hv_Radius,
                        hv_StartPhi, hv_EndPhi, hv_PointOrder, 1);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Circle, HDevWindowStack.GetActive());
                    }
                }
            }
            else
            {
                hv_Row = new HTuple();
                hv_Col = new HTuple();
                hv_Radius = new HTuple();
            }
            ho_cross.Dispose();
            ho_Contour.Dispose();
            ho_Circle.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_cross.Dispose();
            ho_Contour.Dispose();
            ho_Circle.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 通过两个圆环或者圆弧环寻找中间的圆
    public void FindCircle(HObject ho_Image, HTuple hv_TupleAnnular, HTuple hv_Direction,
        HTuple hv_NumPoints, HTuple hv_NumDropPoints, HTuple hv_AmpThreshold, HTuple hv_Smooth,
        HTuple hv_Transition, HTuple hv_Select, out HTuple hv_Row, out HTuple hv_Col,
        out HTuple hv_Radius)
    {



        // Local control variables 

        HTuple hv_RowCircle = new HTuple(), hv_ColCircle = new HTuple();
        HTuple hv_RadiusCircle = new HTuple(), hv_Length = new HTuple();
        HTuple hv_PhiStart = new HTuple(), hv_PhiExtent = new HTuple();

        // Initialize local and output iconic variables 

        hv_Row = new HTuple();
        hv_Col = new HTuple();
        hv_Radius = new HTuple();

        //解析圆数据,根据长度判断是圆环还是圆弧环
        if ((int)(new HTuple((new HTuple(hv_TupleAnnular.TupleLength())).TupleEqual(6))) != 0)
        {
            //由内向外时,中心点和半径以小圆为基准, 长度值为正值
            if ((int)(new HTuple(hv_Direction.TupleEqual("inner"))) != 0)
            {
                if ((int)(new HTuple(((hv_TupleAnnular.TupleSelect(2))).TupleLess(hv_TupleAnnular.TupleSelect(
                    5)))) != 0)
                {
                    hv_RowCircle = hv_TupleAnnular[0];
                    hv_ColCircle = hv_TupleAnnular[1];
                    hv_RadiusCircle = hv_TupleAnnular[2];
                    //大小圆相减,得到查找长度范围
                    hv_Length = (hv_TupleAnnular.TupleSelect(5)) - (hv_TupleAnnular.TupleSelect(
                        2));
                }
                else
                {
                    hv_RowCircle = hv_TupleAnnular[3];
                    hv_ColCircle = hv_TupleAnnular[4];
                    hv_RadiusCircle = hv_TupleAnnular[5];
                    hv_Length = (hv_TupleAnnular.TupleSelect(2)) - (hv_TupleAnnular.TupleSelect(
                        5));
                }
                //由外向内时,中心点和半径以大圆为基准, 长度值为负值
            }
            else
            {
                if ((int)(new HTuple(((hv_TupleAnnular.TupleSelect(2))).TupleLess(hv_TupleAnnular.TupleSelect(
                    5)))) != 0)
                {
                    hv_RowCircle = hv_TupleAnnular[3];
                    hv_ColCircle = hv_TupleAnnular[4];
                    hv_RadiusCircle = hv_TupleAnnular[5];
                    //大小圆相减,得到查找长度范围
                    hv_Length = (hv_TupleAnnular.TupleSelect(2)) - (hv_TupleAnnular.TupleSelect(
                        5));
                }
                else
                {
                    hv_RowCircle = hv_TupleAnnular[0];
                    hv_ColCircle = hv_TupleAnnular[1];
                    hv_RadiusCircle = hv_TupleAnnular[2];
                    //大小圆相减,得到查找长度范围
                    hv_Length = (hv_TupleAnnular.TupleSelect(5)) - (hv_TupleAnnular.TupleSelect(
                        2));
                }
            }
            //起始角度0,结束角度360
            FindCircle_Circle(ho_Image, hv_RowCircle, hv_ColCircle, hv_RadiusCircle, hv_Length,
                (new HTuple(0)).TupleRad(), (new HTuple(360)).TupleRad(), hv_NumPoints,
                hv_NumDropPoints, hv_AmpThreshold, hv_Smooth, hv_Transition, hv_Select,
                out hv_Row, out hv_Col, out hv_Radius);
        }
        else if ((int)(new HTuple((new HTuple(hv_TupleAnnular.TupleLength())).TupleEqual(
            10))) != 0)
        {
            //由内向外时,中心点和半径以小圆为基准, 长度值为正值
            if ((int)(new HTuple(hv_Direction.TupleEqual("inner"))) != 0)
            {
                if ((int)(new HTuple(((hv_TupleAnnular.TupleSelect(2))).TupleLess(hv_TupleAnnular.TupleSelect(
                    7)))) != 0)
                {
                    hv_RowCircle = hv_TupleAnnular[0];
                    hv_ColCircle = hv_TupleAnnular[1];
                    hv_RadiusCircle = hv_TupleAnnular[2];
                    //大小圆相减,得到查找长度范围
                    hv_Length = (hv_TupleAnnular.TupleSelect(7)) - (hv_TupleAnnular.TupleSelect(
                        2));
                    hv_PhiStart = hv_TupleAnnular[3];
                    hv_PhiExtent = hv_TupleAnnular[4];
                }
                else
                {
                    hv_RowCircle = hv_TupleAnnular[5];
                    hv_ColCircle = hv_TupleAnnular[6];
                    hv_RadiusCircle = hv_TupleAnnular[7];
                    //大小圆相减,得到查找长度范围
                    hv_Length = (hv_TupleAnnular.TupleSelect(2)) - (hv_TupleAnnular.TupleSelect(
                        7));
                    hv_PhiStart = hv_TupleAnnular[8];
                    hv_PhiExtent = hv_TupleAnnular[9];
                }
                //由外向内时,中心点和半径以大圆为基准, 长度值为负值
            }
            else
            {
                if ((int)(new HTuple(((hv_TupleAnnular.TupleSelect(2))).TupleLess(hv_TupleAnnular.TupleSelect(
                    7)))) != 0)
                {
                    hv_RowCircle = hv_TupleAnnular[5];
                    hv_ColCircle = hv_TupleAnnular[6];
                    hv_RadiusCircle = hv_TupleAnnular[7];
                    //大小圆相减,得到查找长度范围
                    hv_Length = (hv_TupleAnnular.TupleSelect(2)) - (hv_TupleAnnular.TupleSelect(
                        7));
                    hv_PhiStart = hv_TupleAnnular[8];
                    hv_PhiExtent = hv_TupleAnnular[9];
                }
                else
                {
                    hv_RowCircle = hv_TupleAnnular[0];
                    hv_ColCircle = hv_TupleAnnular[1];
                    hv_RadiusCircle = hv_TupleAnnular[2];
                    //大小圆相减,得到查找长度范围
                    hv_Length = (hv_TupleAnnular.TupleSelect(7)) - (hv_TupleAnnular.TupleSelect(
                        2));
                    hv_PhiStart = hv_TupleAnnular[3];
                    hv_PhiExtent = hv_TupleAnnular[4];
                }
            }
            FindCircle_Circle(ho_Image, hv_RowCircle, hv_ColCircle, hv_RadiusCircle, hv_Length,
                hv_PhiStart, hv_PhiExtent, hv_NumPoints, hv_NumDropPoints, hv_AmpThreshold,
                hv_Smooth, hv_Transition, hv_Select, out hv_Row, out hv_Col, out hv_Radius);

        }


        return;
    }

    // Short Description: 寻找制定图像区域的边缘点。
    public void FindPoint(HObject ho_Image, HTuple hv_MsrHandle, HTuple hv_Smooth,
        HTuple hv_AmpThreshold, HTuple hv_Transition, HTuple hv_Select, out HTuple hv_Row,
        out HTuple hv_Col)
    {



        // Local control variables 

        HTuple hv_Amplitude_Measure = new HTuple();
        HTuple hv_Distance_Measure = new HTuple(), hv_Row_Measure = new HTuple();
        HTuple hv_Col_Measure = new HTuple(), hv_num = new HTuple();
        HTuple hv_Indices = new HTuple(), hv_index = new HTuple();

        // Initialize local and output iconic variables 

        hv_Row = new HTuple();
        hv_Col = new HTuple();

        //取第一点或最后一点时,直接调用
        if ((int)((new HTuple(hv_Select.TupleEqual("first"))).TupleOr(new HTuple(hv_Select.TupleEqual(
            "last")))) != 0)
        {
            HOperatorSet.MeasurePos(ho_Image, hv_MsrHandle, hv_Smooth, hv_AmpThreshold,
                hv_Transition, hv_Select, out hv_Row, out hv_Col, out hv_Amplitude_Measure,
                out hv_Distance_Measure);
        }
        else if ((int)(new HTuple(hv_Select.TupleEqual("strongest"))) != 0)
        {
            //取最强点是,需要全部查找出来排序取最大值
            HOperatorSet.MeasurePos(ho_Image, hv_MsrHandle, hv_Smooth, hv_AmpThreshold,
                hv_Transition, "all", out hv_Row_Measure, out hv_Col_Measure, out hv_Amplitude_Measure,
                out hv_Distance_Measure);
            HOperatorSet.TupleLength(hv_Row_Measure, out hv_num);
            if ((int)(new HTuple(hv_num.TupleGreater(0))) != 0)
            {
                HOperatorSet.TupleSortIndex(hv_Amplitude_Measure, out hv_Indices);
                hv_index = hv_Indices.TupleSelect(hv_num - 1);
                hv_Row = hv_Row_Measure.TupleSelect(hv_index);
                hv_Col = hv_Col_Measure.TupleSelect(hv_index);
            }
        }



        return;
    }

    public void dev_disp_message(HTuple hv_String, HTuple hv_CoordSystem, HTuple hv_Row,
        HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
    {


        // Local control variables 

        HTuple hv_WindowHandle = null;

        // Initialize local and output iconic variables 


        //获取当前活动窗口
        hv_WindowHandle = -1;
        if (HDevWindowStack.IsOpen())
        {
            hv_WindowHandle = HDevWindowStack.GetActive();
        }
        if ((int)(new HTuple(hv_WindowHandle.TupleNotEqual(-1))) != 0)
        {
            disp_message(hv_WindowHandle, hv_String, hv_CoordSystem, hv_Row, hv_Column,
                hv_Color, hv_Box);
        }

        return;
    }

    // Short Description: 通过输入图像查找模板获取转换的坐标矩阵。
    public void FindTemplete(HObject ho_Image, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_ModelScore, out HTuple hv_FixTool)
    {



        // Local control variables 

        HTuple hv_ModelRow = null, hv_ModelColumn = null;
        HTuple hv_ModelAngle = null, hv_ModelScale = null;

        // Initialize local and output iconic variables 

        hv_FixTool = new HTuple();


        HOperatorSet.FindScaledShapeModel(ho_Image, hv_ModelId, (new HTuple(0)).TupleRad()
            , (new HTuple(360)).TupleRad(), 0.95, 1.05, 0.40, 1, 0.5, "least_squares",
            (new HTuple(5)).TupleConcat(1), 0.75, out hv_ModelRow, out hv_ModelColumn,
            out hv_ModelAngle, out hv_ModelScale, out hv_ModelScore);
        if ((int)(new HTuple((new HTuple(hv_ModelScore.TupleLength())).TupleGreater(0))) != 0)
        {
            //生成座标转换矩阵
            HOperatorSet.VectorAngleToRigid(hv_ModelData.TupleSelect(0), hv_ModelData.TupleSelect(
                1), hv_ModelData.TupleSelect(2), hv_ModelRow, hv_ModelColumn, hv_ModelAngle,
                out hv_FixTool);
            //显示找到的轮廓
            if ((int)(1) != 0)
            {
                dev_display_shape_matching_results(hv_ModelId, "red", hv_ModelRow, hv_ModelColumn,
                    hv_ModelAngle, 1, 1, 0);
                //DetlaAngle := ModelAngle - InitAngle
            }
            //显示模板查找得分信息

            dev_disp_message("Model Score is " + hv_ModelScore, "window", 20, 20, "green",
                "false");

        }
        else
        {
            //ModelScore := []
            dev_disp_message("Model find fail !", "window", 20, 20, "red", "true");
        }

        return;
    }

    // Local procedures 
    // Short Description: 图像处理过程。
    public void T1_1(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_2(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 


        // Local control variables 

        HTuple hv_FixTool = null, hv_Score = null;

        // Initialize local and output iconic variables 

        try
        {
            //先赋值，以免发生异常后读取非法内存
            //TupleResult := -999
            //读取ROI,旋转矩形,带方向角度,判断举行区域面积,盖子没掀开时亮度高
            //ReadRoiRectangle2 (Directory + '/rect.roi', RoiDataIn)
            //根据模板查找的座标来转换ROI
            //TranslateRoi (FixTool, RoiDataIn, RoiDataOut)
            //gen_rectangle2 (RectRegion, RoiDataOut[0], RoiDataOut[1], RoiDataOut[2], RoiDataOut[3], RoiDataOut[4])
            if (HDevWindowStack.IsOpen())
            {
                //dev_display (RectRegion)
            }
            //maxArea := RoiDataOut[3]*RoiDataOut[4]*4
            //reduce_domain (Image, RectRegion, ImageReduced)
            //threshold (ImageReduced, Region1, 50, 255)
            //connection (Region1, ConnectedRegions)
            //select_shape (Region1, SelectedRegions, 'area', 'and', maxArea*0.8, maxArea*1.1)
            //count_obj (SelectedRegions, Number)
            //if (Number == 1)
            //dev_disp_message ('cover is take ok!', 'window', 40, 20, 'green', 'false')
            //TupleResult := [1]
            //stop ()
            //return ()
            //else
            //TupleResult := -999
            //dev_disp_message ('cover is take wrong!', 'window', 40, 20, 'red', 'false')
            //endif

            //return ()

            hv_TupleResult = -999;
            FindTemplete(ho_Image, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                dev_disp_message("cover is take ok!", "window", 40, 20, "green", "false");
                hv_TupleResult = 1;
            }
            else
            {
                //模板查找失败
                dev_disp_message("cover is take wrong!", "window", 40, 20, "red", "false");
                hv_TupleResult = -999;
            }

            return;


        }
        catch (HalconException HDevExpDefaultException)
        {

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_3(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_RowBegin3 = new HTuple(), hv_ColBegin3 = new HTuple();
        HTuple hv_RowEnd3 = new HTuple(), hv_ColEnd3 = new HTuple();
        HTuple hv_Angle3 = new HTuple(), hv_RowP1 = new HTuple();
        HTuple hv_ColP1 = new HTuple(), hv_IsOverlapping = new HTuple();
        HTuple hv_RowP2 = new HTuple(), hv_ColP2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            //先赋值，以免发生异常后读取非法内存
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }

            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 50.55, 50.447, 1569.19, 2058.33);
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);

            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple(hv_Score.TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Bottom.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                //hom_mat2d_identity (FixTool)
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " BottomLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Left.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "positive", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();


                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin3, out hv_ColBegin3, out hv_RowEnd3, out hv_ColEnd3);
                if ((int)(new HTuple((new HTuple(hv_RowBegin3.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(("Error= " + hv_TupleResult) + " RightLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd3, hv_ColEnd3, hv_RowBegin3, hv_ColBegin3,
                    out hv_Angle3);
                hv_Angle3 = hv_Angle3.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_RowP1, out hv_ColP1,
                    out hv_IsOverlapping);
                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin3, hv_ColBegin3, hv_RowEnd3, hv_ColEnd3, out hv_RowP2, out hv_ColP2,
                    out hv_IsOverlapping);
                hv_Row = (hv_RowP1 + hv_RowP2) / 2;
                hv_Col = (hv_ColP1 + hv_ColP2) / 2;
                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle3= " + hv_Angle3, "window", 120, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 140,
                        20, "green", "false");
                    dev_disp_message("Angle3-Angle= " + (hv_Angle3 - hv_Angle), "window", 160,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }
            //* else
            //dev_disp_message ('No bottom Panle', 'window', 40, 20, 'green', 'false')
            //TupleResult := -1000
            //* endif
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_4(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_Radius = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            //先赋值，以免发生异常后读取非法内存
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }

            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);

            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,圆环
                ReadRoiAnnularCircle(hv_Directory + "/T1_4.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找圆,方向outer指定由外向内,以大圆半径为中心,100个点,可排除20个干扰点,阈值5,
                //平滑系数0.4, 由白到黑,取第一点
                FindCircle(ho_Image, hv_RoiDataOut, "inner", 100, 20, 5, 0.4, "positive",
                    "first", out hv_Row, out hv_Col, out hv_Radius);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -998;
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }

                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);

                dev_disp_message("row= " + hv_Row, "window", 40, 20, "green", "false");
                dev_disp_message("col= " + hv_Col, "window", 60, 20, "green", "false");
                //dev_disp_message ('Angle= '+ Angle, 'window', 80, 20, 'green', 'false')
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                }
                hv_TupleResult = new HTuple();
                hv_TupleResult[0] = 1;
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }
            //* else
            //dev_disp_message ('No bottom Panle', 'window', 40, 20, 'green', 'false')
            //TupleResult := -1000
            //* endif
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_calib(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId,
        HTuple hv_ModelData, out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void T1_calib2(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId,
        HTuple hv_ModelData, out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_Radius = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            //先赋值，以免发生异常后读取非法内存
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }

            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);

            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple(hv_Score.TupleGreater(0.8))) != 0)
            {
                //读取第一个ROI,圆环
                ReadRoiAnnularCircle(hv_Directory + "/T1_calib2.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找圆,方向outer指定由外向内,以大圆半径为中心,100个点,可排除20个干扰点,阈值5,
                //平滑系数0.4, 由白到黑,取第一点
                FindCircle(ho_Image, hv_RoiDataOut, "inner", 100, 20, 5, 0.4, "positive",
                    "first", out hv_Row, out hv_Col, out hv_Radius);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -998;
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }

                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);

                dev_disp_message("row= " + hv_Row, "window", 40, 20, "green", "false");
                dev_disp_message("col= " + hv_Col, "window", 60, 20, "green", "false");
                //dev_disp_message ('Angle= '+ Angle, 'window', 80, 20, 'green', 'false')
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                }
                hv_TupleResult = new HTuple();
                hv_TupleResult[0] = 1;
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }
            //* else
            //dev_disp_message ('No bottom Panle', 'window', 40, 20, 'green', 'false')
            //TupleResult := -1000
            //* endif
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_10(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_11(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_12(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_13(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_14(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_15(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_16(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_17(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_18(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_19(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_20(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_21(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_22(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_23(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_24(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T1_25(HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_ROI_0, ho_ImageReduced, ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_RowBegin2 = new HTuple();
        HTuple hv_ColBegin2 = new HTuple(), hv_RowEnd2 = new HTuple();
        HTuple hv_ColEnd2 = new HTuple(), hv_Angle2 = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_IsOverlapping = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            ho_ROI_0.Dispose();
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 2748, 3840);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ROI_0, HDevWindowStack.GetActive());
            }
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //进行模板查找
            FindTemplete(ho_ImageReduced, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Down.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -998;
                    dev_disp_message(("Error= " + hv_TupleResult) + " TopLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd1, hv_ColEnd1, hv_RowBegin1, hv_ColBegin1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/Right.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(ho_Image, hv_RoiDataOut, 60, 30, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin2, out hv_ColBegin2, out hv_RowEnd2, out hv_ColEnd2);
                if ((int)(new HTuple((new HTuple(hv_RowBegin2.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    dev_disp_message(("Error= " + hv_TupleResult) + " LeftLine Find Fail!", "window",
                        60, 20, "red", "false");
                    ho_ROI_0.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowEnd2, hv_ColEnd2, hv_RowBegin2, hv_ColBegin2,
                    out hv_Angle2);
                hv_Angle2 = hv_Angle2.TupleDeg();

                HOperatorSet.IntersectionLines(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    hv_RowBegin2, hv_ColBegin2, hv_RowEnd2, hv_ColEnd2, out hv_Row, out hv_Col,
                    out hv_IsOverlapping);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -996;
                    dev_disp_message(new HTuple("Error= ") + "Center Find Fail!", "window", 60,
                        20, "red", "false");
                }
                else
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                    }
                    dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                    dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                    dev_disp_message("Angle= " + hv_Angle, "window", 80, 20, "green", "false");
                    dev_disp_message("Angle2= " + hv_Angle2, "window", 100, 20, "green", "false");
                    dev_disp_message("Angle2-Angle= " + (hv_Angle2 - hv_Angle), "window", 120,
                        20, "green", "false");

                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);
                }
            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ROI_0.Dispose();
            ho_ImageReduced.Dispose();
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Main procedure 
    private void action()
    {

        // Local iconic variables 

        HObject ho_Image = null;


        // Local control variables 

        HTuple hv_window = null, hv_nSelect = null;
        HTuple hv_Product = null, hv_dir = null, hv_ModelId = null;
        HTuple hv_ModelData = null, hv_ImageFiles = null, hv_Index = null;
        HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
        HTuple hv_TupleResult = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Image);

        try
        {
            HOperatorSet.SetWindowAttr("background_color", "black");
            HOperatorSet.OpenWindow(0, 0, 800, 640, 0, "", "", out hv_window);
            HDevWindowStack.Push(hv_window);
            //产品类型
            hv_nSelect = "T1_25";
            hv_Product = "laser";
            //文件路径
            hv_dir = "E:/AutoFrame/Exe/VisionConfig/";
            //产品路径
            hv_dir = ((hv_dir + hv_Product) + "/") + hv_nSelect;
            //初始化模板
            InitTemplete(hv_dir, out hv_ModelId, out hv_ModelData);
            //遍历文件夹，查找所有图片类型
            HOperatorSet.ListFiles(hv_dir, ((new HTuple("files")).TupleConcat("recursive")).TupleConcat(
                "follow_links"), out hv_ImageFiles);
            HOperatorSet.TupleRegexpSelect(hv_ImageFiles, (new HTuple("\\.(tif|tiff|gif|bmp|jpg|jpeg|                       jp2|png|pcx|pgm|ppm|pbm|xwd|ima)$")).TupleConcat(
                "ignore_case"), out hv_ImageFiles);
            //处理文件夹内所有图片
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ImageFiles.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                ho_Image.Dispose();
                HOperatorSet.ReadImage(out ho_Image, hv_ImageFiles.TupleSelect(hv_Index));
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                }
                HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                }
                if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_1"))) != 0)
                {
                    //处理指定类型工件，找出关键点坐标并提取显示。
                    T1_1(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_2"))) != 0)
                {
                    T1_2(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_3"))) != 0)
                {
                    T1_3(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_4"))) != 0)
                {
                    T1_4(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                    //****************新增模块处理步骤共预留16个***********************
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_10"))) != 0)
                {
                    T1_10(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_11"))) != 0)
                {
                    T1_11(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_12"))) != 0)
                {
                    T1_12(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_13"))) != 0)
                {
                    T1_13(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_14"))) != 0)
                {
                    T1_14(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_15"))) != 0)
                {
                    T1_15(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_16"))) != 0)
                {
                    T1_16(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_17"))) != 0)
                {
                    T1_17(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_18"))) != 0)
                {
                    T1_18(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_19"))) != 0)
                {
                    T1_19(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_20"))) != 0)
                {
                    T1_20(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_21"))) != 0)
                {
                    T1_21(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_22"))) != 0)
                {
                    T1_22(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_23"))) != 0)
                {
                    T1_23(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_24"))) != 0)
                {
                    T1_24(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_25"))) != 0)
                {
                    T1_25(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                    //***********************标定处理步骤*********************************
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_calib"))) != 0)
                {
                    T1_calib(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_calib2"))) != 0)
                {
                    T1_calib2(ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                //等待一段时间s
                HOperatorSet.WaitSeconds(0.1);
            }
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Image.Dispose();

            throw HDevExpDefaultException;
        }
        ho_Image.Dispose();

    }


}
#if !NO_EXPORT_APP_MAIN
public class HDevelopExportApp
{
  static void Main(string[] args)
  {
    new HDevelopExport();
  }
}
#endif

