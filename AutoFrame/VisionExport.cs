##############################################################################
#   File generated by HDevelop
##############################################################################
# Procedures 
# External procedures 
# Chapter: Matching / Shape-Based
# Short Description: Display the results of Shape-Based Matching.
procedure dev_display_shape_matching_results (: : ModelID, Color, Row, Column, Angle, 
    ScaleR, ScaleC, Model: )
  * This procedure displays the results of Shape-Based Matching.
  * 
  NumMatches := |Row|
  if (NumMatches>0)
      if (|ScaleR|=1)
          tuple_gen_const (NumMatches, ScaleR, ScaleR)
      endif
      if (|ScaleC|=1)
          tuple_gen_const (NumMatches, ScaleC, ScaleC)
      endif
      if (|Model|=0)
          tuple_gen_const (NumMatches, 0, Model)
      elseif (|Model|=1)
          tuple_gen_const (NumMatches, Model, Model)
      endif
      for Index := 0 to |ModelID|-1 by 1
          get_shape_model_contours (ModelContours, ModelID[Index], 1)
          dev_set_color (Color[Index%|Color|])
          for Match := 0 to NumMatches-1 by 1
              if (Index=Model[Match])
                  hom_mat2d_identity (HomMat2DIdentity)
                  hom_mat2d_scale (HomMat2DIdentity, ScaleR[Match], ScaleC[Match], 0, 0, HomMat2DScale)
                  hom_mat2d_rotate (HomMat2DScale, Angle[Match], 0, 0, HomMat2DRotate)
                  hom_mat2d_translate (HomMat2DRotate, Row[Match], Column[Match], HomMat2DTranslate)
                  affine_trans_contour_xld (ModelContours, ContoursAffinTrans, HomMat2DTranslate)
                  dev_display (ContoursAffinTrans)
              endif
          endfor
      endfor
  endif
  return ()


# Chapter: Graphics / Text
# Short Description: This procedure writes a text message.
procedure disp_message (: : WindowHandle, String, CoordSystem, Row, Column, Color, 
    Box: )
  * This procedure displays text in a graphics window.
  * 
  * Input parameters:
  * WindowHandle: The WindowHandle of the graphics window, where
  *    the message should be displayed
  * String: A tuple of strings containing the text message to be displayed
  * CoordSystem: If set to 'window', the text position is given
  *    with respect to the window coordinate system.
  *    If set to 'image', image coordinates are used.
  *    (This may be useful in zoomed images.)
  * Row: The row coordinate of the desired text position
  *    If set to -1, a default value of 12 is used.
  * Column: The column coordinate of the desired text position
  *    If set to -1, a default value of 12 is used.
  * Color: defines the color of the text as string.
  *    If set to [], '' or 'auto' the currently set color is used.
  *    If a tuple of strings is passed, the colors are used cyclically
  *    for each new textline.
  * Box: If set to 'true', the text is written within a white box.
  * 
  * prepare window
  get_rgb (WindowHandle, Red, Green, Blue)
  get_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)
  get_window_extents (WindowHandle, RowWin, ColumnWin, WidthWin, HeightWin)
  set_part (WindowHandle, 0, 0, HeightWin-1, WidthWin-1)
  * 
  * default settings
  if (Row=-1)
      Row := 12
  endif
  if (Column=-1)
      Column := 12
  endif
  if (Color=[])
      Color := ''
  endif
  * 
  String := split(''+String+'','\n')
  * 
  * Estimate extentions of text depending on font size.
  get_font_extents (WindowHandle, MaxAscent, MaxDescent, MaxWidth, MaxHeight)
  if (CoordSystem='window')
      R1 := Row
      C1 := Column
  else
      * transform image to window coordinates
      FactorRow := 1.*HeightWin/(Row2Part-Row1Part+1)
      FactorColumn := 1.*WidthWin/(Column2Part-Column1Part+1)
      R1 := (Row-Row1Part+0.5)*FactorRow
      C1 := (Column-Column1Part+0.5)*FactorColumn
  endif
  * 
  * display text box depending on text size
  if (Box='true')
      * calculate box extents
      String := ' '+String+' '
      Width := []
      for Index := 0 to |String|-1 by 1
          get_string_extents (WindowHandle, String[Index], Ascent, Descent, W, H)
          Width := [Width,W]
      endfor
      FrameHeight := MaxHeight*|String|
      FrameWidth := max([0,Width])
      R2 := R1+FrameHeight
      C2 := C1+FrameWidth
      * display rectangles
      get_draw (WindowHandle, DrawMode)
      set_draw (WindowHandle, 'fill')
      set_color (WindowHandle, 'light gray')
      disp_rectangle1 (WindowHandle, R1+3, C1+3, R2+3, C2+3)
      set_color (WindowHandle, 'white')
      disp_rectangle1 (WindowHandle, R1, C1, R2, C2)
      set_draw (WindowHandle, DrawMode)
  elseif (Box#'false')
      Exception := 'Wrong value of control parameter Box'
      throw (Exception)
  endif
  * Write text.
  for Index := 0 to |String|-1 by 1
      CurrentColor := Color[Index%|Color|]
      if (CurrentColor#'' and CurrentColor#'auto')
          set_color (WindowHandle, CurrentColor)
      else
          set_rgb (WindowHandle, Red, Green, Blue)
      endif
      Row := R1+MaxHeight*Index
      set_tposition (WindowHandle, Row, C1)
      write_string (WindowHandle, String[Index])
  endfor
  * reset changed window settings
  set_rgb (WindowHandle, Red, Green, Blue)
  set_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)
  return ()


# Short Description: 读取模板得到模板中心点和角度。
procedure InitTemplete (: : Directory: ModelId, ModelData)
  * 
  ModelData := []
  read_image (ImageModel, Directory + '/Model.bmp')
  dev_display (ImageModel)
  WindowHandle := -1
  dev_get_window (WindowHandle)
  * 
  * tuple_length (WindowHandle, num)
  read_shape_model (Directory + '/Model.shm', ModelId)
  * 模板图片查找模板位置,不需要使用变形模板
  find_shape_model (ImageModel, ModelId, rad(0), rad(360), 0.6, 1, 0.5, 'least_squares', [5,1], 0.75, ModelRow, ModelColumn, ModelAngle, ModelScore)
  * Matching 01: transform the model contours into the detected positions
  if (|ModelScore| > 0)
      * 存储模板位置信息
      tuple_concat (ModelData, ModelRow, ModelData)
      tuple_concat (ModelData, ModelColumn, ModelData)
      tuple_concat (ModelData, ModelAngle, ModelData)
      * 
      dev_display_shape_matching_results (ModelId, 'red', ModelRow, ModelColumn, ModelAngle, 1, 1, 0)
      dev_disp_message ('Model Score is '+ ModelScore, 'window', 20, 20, 'green', 'false')
  else
      * 
      dev_disp_message ('Model find fail !', 'window', 20, 20, 'red', 'true')
      * 
  endif
  return ()


# Short Description: 从ROI文件中读取旋转矩形参数
procedure ReadRoiRectangle2 (: : FileName: TupleData)
  * 
  open_file (FileName, 'input', FileHandle)
  IsEOF := 0
  x := 0
  y := 10
  TupleData := []
  while (IsEOF == 0)
      fread_string (FileHandle, strText, IsEOF)
      if (strText == '<roi')
          while (IsEOF == 0)
              fread_string (FileHandle, strText, IsEOF)
  *             disp_message (Window, strText, 'window', x, y, 'red', 'false')
              x := x+15
              if (strText == '<rect2')
                  fread_string (FileHandle, strOp, IsEOF)
                  fread_string (FileHandle, strData, IsEOF)
                  fread_string (FileHandle, len1, IsEOF)
                  fread_string (FileHandle, len2, IsEOF)
                  fread_string (FileHandle, row, IsEOF)
                  fread_string (FileHandle, col, IsEOF)
                  fread_string (FileHandle, phi, IsEOF)
  *                 disp_message (Window, strOp + len1+len2+row+col+phi, 'window', x, y, 'red', 'false')
                  x := x+15
                  tuple_regexp_match (row, '="(.*)"', row)
                  tuple_number (row, row)
                  tuple_regexp_match (col, '="(.*)"', col)
                  tuple_number (col, col)
                  tuple_regexp_match (phi, '="(.*)"', phi)
                  tuple_number (phi, phi)
                  tuple_regexp_match (len1, '="(.*)"', len1)
                  tuple_number (len1, len1)
                  tuple_regexp_match (len2, '="(.*)"', len2)
                  tuple_number (len2, len2)
                  * 
                  tuple_concat (TupleData, row, TupleData)
                  tuple_concat (TupleData, col, TupleData)
                  tuple_concat (TupleData, phi, TupleData)
                  tuple_concat (TupleData, len1, TupleData)
                  tuple_concat (TupleData, len2, TupleData)
                  * 
  *                 tuple_regexp_match (strOp, '="(.*)"', strOp)
  *                 if (strOp == 'none')
  *                     gen_rectangle2 (Region, row, col, rad(phi), len1, len2)
  *                 else
  *                     gen_rectangle2 (Rectangle2, row, col, rad(phi), len1, len2)
  *                     if (strOp == 'union')
  *                         union2 (Region, Rectangle2, Region)
  *                     elseif (strOp == 'intersection')
  *                         intersection (Region, Rectangle2, Region)
  *                     elseif (strOp == 'difference')
  *                         difference (Region, Rectangle2, Region)
  *                     else
  *                         disp_message (Window, strOp + 'not support!', 'window', x, y, 'red', 'false')
  *                         x := x+15
  *                     endif
  *                 endif
              endif
          endwhile
      endif
  endwhile
  close_file (FileHandle)
  return ()


# Short Description: 得到转换后的ROI数据。
procedure TranslateRoi (: : FixTool, TupleDataIn: TupleDataOut)
  hom_mat2d_to_affine_par (FixTool, Sx, Sy, Phi, Theta, Tx, Ty)
  tuple_length (TupleDataIn, Number)
  TupleDataOut := []
  * 旋转矩形
  if (Number == 5)
      affine_trans_point_2d (FixTool, TupleDataIn[0], TupleDataIn[1], row, col)
      TupleDataOut[0] := row
      TupleDataOut[1] := col
      * 加上模板查找的角度并转换为弧角度
      TupleDataOut[2] := rad(TupleDataIn[2]) + Phi
      TupleDataOut[3] := TupleDataIn[3]
      TupleDataOut[4] := TupleDataIn[4]
  *     gen_rectangle2 (Rectangle, TupleDataOut[0], TupleDataOut[1], TupleDataOut[2], TupleDataOut[3], TupleDataOut[4])
      * 
      * 圆环
  elseif (Number == 6)
      affine_trans_point_2d (FixTool, TupleDataIn[0], TupleDataIn[1], row, col)
      TupleDataOut[0] := row
      TupleDataOut[1] := col
      * 圆没有角度
      TupleDataOut[2] := TupleDataIn[2]
      affine_trans_point_2d (FixTool, TupleDataIn[3], TupleDataIn[4], row, col)
      TupleDataOut[3] := row
      TupleDataOut[4] := col
      TupleDataOut[5] := TupleDataIn[5]
      * 圆弧环
  elseif (Number == 10)
      TupleDataOut := TupleDataIn
      affine_trans_point_2d (FixTool, TupleDataIn[0], TupleDataIn[1], row, col)
      TupleDataOut[0] := row
      TupleDataOut[1] := col
      * 圆弧需要计算起始角度
      TupleDataOut[3] := rad(TupleDataIn[3])+ Phi
      TupleDataOut[4] := rad(TupleDataIn[4])
      * 
      affine_trans_point_2d (FixTool, TupleDataIn[5], TupleDataIn[6], row, col)
      TupleDataOut[5] := row
      TupleDataOut[6] := col
      TupleDataOut[8] := rad(TupleDataIn[8])+ Phi
      TupleDataOut[9] := rad(TupleDataIn[9])
      * 不支持的格式
  else
      * 
  endif
  * 
  * 
  * 
  return ()


# Short Description: 通过输入参数寻找区域当中的直线
procedure FindLine (Image: : TupleRectangle2, NumPoints, RectWidth, NumDropPoints, 
    AmpThreshold, Smooth, Transition, Select: RowBegin, ColBegin, RowEnd, ColEnd)
  * 解析ROI数据,转入查找直线函数
  FindLine_Rectangle2 (Image, TupleRectangle2[0], TupleRectangle2[1], TupleRectangle2[2], TupleRectangle2[3], TupleRectangle2[4], NumPoints, RectWidth, NumDropPoints, AmpThreshold, Smooth, Transition, Select, RowBegin, ColBegin, RowEnd, ColEnd)


# Short Description: 读取圆roi的中心坐标以及半径。
procedure ReadRoiAnnularCircle (: : FileName: TupleData)
  * 
  open_file (FileName, 'input', FileHandle)
  IsEOF := 0
  x := 0
  y := 0
  TupleData := []
  while (IsEOF == 0)
      fread_string (FileHandle, strText, IsEOF)
      * 判断是否是ROI区
      if (strText == '<roi')
          while (IsEOF == 0)
              fread_string (FileHandle, strText, IsEOF)
  *             disp_message (Window, strText, 'window', x, y, 'red', 'false')
  *             x := x+15
              * 判断是否是圆
              if (strText == '<circle')
                  fread_string (FileHandle, strOp, IsEOF)
                  fread_string (FileHandle, strData, IsEOF)
                  fread_string (FileHandle, row, IsEOF)
                  fread_string (FileHandle, radius, IsEOF)
                  fread_string (FileHandle, col, IsEOF)
  *                 disp_message (Window, strOp + row+radius+col, 'window', x, y, 'red', 'false')
  *                 x := x+15
                  tuple_regexp_match (row, '="(.*)"', row)
                  tuple_number (row, row)
                  tuple_regexp_match (col, '="(.*)"', col)
                  tuple_number (col, col)
                  tuple_regexp_match (radius, '="(.*)"', radius)
                  tuple_number (radius, radius)
                  * 
                  tuple_regexp_match (strOp, '="(.*)"', strOp)
                  * 
                  tuple_concat (TupleData, row, TupleData)
                  tuple_concat (TupleData, col, TupleData)
                  tuple_concat (TupleData, radius, TupleData)
  *                 if (strOp == 'none')
  *                     gen_circle (Region, row, col, radius)
  *                 else
  *                     gen_circle (Circle, row, col, radius)
  *                     if (strOp == 'union')
  *                         union2 (Region, Circle, Region)
  *                     elseif (strOp == 'intersection')
  *                         intersection (Region, Circle, Region)
  *                     elseif (strOp == 'difference')
  *                         difference (Region, Circle, Region)
  *                     else
  *                         disp_message (Window, strOp + 'not support!', 'window', x, y, 'red', 'false')
  *                         x := x+15
  *                     endif
  *                 endif
              endif
          endwhile
      endif
  endwhile
  close_file (FileHandle)
  return ()
  * 
  * 
  * 


# Short Description: 通过输入带角度的矩形框寻找中间的直线
procedure FindLine_Rectangle2 (Image: : Row, Col, Phi, Len1, Len2, NumPoints, RectWidth, 
    NumDropPoints, AmpThreshold, Smooth, Transition, Select: RowBegin, ColBegin, 
    RowEnd, ColEnd)
  * 
  * 
  get_image_size (Image, imgWidth, imgHeight)
  * 
  Rect_Row := []
  Rect_Col := []
  RowOut := []
  ColOut := []
  * 
  * 计算量测小矩形的座标位置及角度
  Rect_offset := Len1/NumPoints
  Phi_Tmp := Phi + rad(90)
  Rect_Row := Row  + Len2 * sin(Phi_Tmp) -Rect_offset * sin(Phi_Tmp) /2
  Rect_Col := Col - Len2 * cos(Phi_Tmp)+ Rect_offset * cos(Phi_Tmp) /2
  Rect_Phi := Phi
  Rect_Len1 := Len1
  Rect_Len2 := RectWidth/2
  * 
  hom_mat2d_identity (HomMat2DIdentity)
  hom_mat2d_translate (HomMat2DIdentity, -Len2* 2 * sin(Phi_Tmp) /NumPoints, Len2 * cos(Phi_Tmp)* 2 /NumPoints, HomMat2DTranslate)
  gen_measure_rectangle2 (Rect_Row, Rect_Col, Rect_Phi, Rect_Len1, Rect_Len2, imgWidth, imgHeight, 'nearest_neighbor', MsrHandle)
  * 
  for Index := 0 to NumPoints-1 by 1
      * 显示当前的量测矩形区域
      if (1)
          dev_set_color ('green')
          dev_set_draw ('margin')
          dev_get_window (WindowHandle)
          disp_rectangle2 (WindowHandle, Rect_Row, Rect_Col, Rect_Phi, Rect_Len1, Rect_Len2)
      endif
      * 查找边缘点
      FindPoint (Image, MsrHandle, Smooth, AmpThreshold, Transition, Select, RowMeasure, ColMeasure)
      tuple_length (RowMeasure, num)
      if (num > 0)
          tuple_concat (RowOut, RowMeasure, RowOut)
          tuple_concat (ColOut, ColMeasure, ColOut)
      endif
      * 旋转及平移量测区区域
      affine_trans_pixel (HomMat2DTranslate, Rect_Row, Rect_Col, Rect_Row, Rect_Col)
      translate_measure (MsrHandle, Rect_Row, Rect_Col)
  endfor
  close_measure (MsrHandle)
  * 
  * 要求获取到的最终的边缘点大于总点数的一半
  if (|RowOut| > NumPoints / 10)
      * 绘制每个边缘点
      if (1)
          dev_set_color ('blue')
          gen_cross_contour_xld (cross, RowOut, ColOut, 10, 0.785398)
          dev_display (cross)
      endif
      * 
      * 
      gen_contour_polygon_xld (Contour, RowOut, ColOut)
      fit_line_contour_xld (Contour, 'tukey', NumPoints * 0.9, 0, 15, 5, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)
      * 显示查找到的直线
      if (1)
          dev_set_color ('red')
          rowLine := []
          colLine := []
          tuple_concat (rowLine, RowBegin, rowLine)
          tuple_concat (rowLine, RowEnd, rowLine)
          tuple_concat (colLine, ColBegin, colLine)
          tuple_concat (colLine, ColEnd, colLine)
          gen_contour_polygon_xld (Line, rowLine, colLine)
          dev_display (Line)
      endif
  else
      RowBegin := []
      ColBegin := []
      RowEnd := []
      ColEnd := []
  endif
  return ()
  * 
  * 


procedure FindCircle_Circle (Image: : RowCircle, ColCircle, RadiusCircle, Length, 
    PhiStart, PhiExtent, NumPoints, NumDropPoints, AmpThreshold, Smooth, Transition, 
    Select: Row, Col, Radius)
  * 
  get_image_size (Image, imgWidth, imgHeight)
  RowOut := []
  ColOut := []
  * 
  * 分割矩形的中心坐标
  Row_Rect := RowCircle - sin(PhiStart) * (RadiusCircle + Length / 2)
  Col_Rect := ColCircle + cos(PhiStart) * (RadiusCircle + Length / 2)
  * 
  * 分割角度
  Angle := (PhiExtent / NumPoints)
  RoiWidth := sin(Angle) * (RadiusCircle + Length / 2) / 2
  * 
  * 显示整体的ROI区域
  * dev_get_window (WindowHandle)
  * disp_circle (WindowHandle, RowCircle, ColCircle, RadiusCircle)
  * disp_circle (WindowHandle, RowCircle, ColCircle, RadiusCircle + Length)
  * 
  if (Length > 0)
      * 由内向外
      direction := 0
  else
      * 由外向内
      direction := rad(180)
      Length := -Length
  endif
  * 
  hom_mat2d_identity (HomMat2DIdentity)
  hom_mat2d_rotate (HomMat2DIdentity, Angle, RowCircle, ColCircle, HomMat2DRotate)
  for Index := 0 to NumPoints-1 by 1
      * 显示当前查找边缘的ROI区
      if (0)
          dev_set_color ('green')
          dev_set_draw ('margin')
          dev_get_window (WindowHandle)
          disp_rectangle2 (WindowHandle, Row_Rect, Col_Rect, PhiStart + Index * Angle+  direction, Length / 2, RoiWidth)
      endif
      * 
      gen_measure_rectangle2 (Row_Rect, Col_Rect, PhiStart + Index *                              Angle + direction, Length/2, RoiWidth, imgWidth, imgHeight, 'nearest_neighbor', MsrHandle)
      * 查找边缘点
      FindPoint (Image, MsrHandle, Smooth, AmpThreshold, Transition, Select, RowMeasure, ColMeasure)
      tuple_length (RowMeasure, num)
      if (num > 0)
          tuple_concat (RowOut, RowMeasure, RowOut)
          tuple_concat (ColOut, ColMeasure, ColOut)
      endif
      close_measure (MsrHandle)
      * 旋转量测区域中心点
      affine_trans_pixel (HomMat2DRotate, Row_Rect, Col_Rect, Row_Rect, Col_Rect)
  endfor
  * 要求获取到的最终的边缘点大于总点数的一半
  if (|RowOut| > NumPoints / 2)
      * 显示所有找到的边缘点
      if (1)
          dev_set_color ('blue')
          gen_cross_contour_xld (cross, RowOut, ColOut, 15, 0.785398)
          dev_display (cross)
      endif
      * 
      gen_contour_polygon_xld (Contour, RowOut, ColOut)
      fit_circle_contour_xld (Contour, 'atukey', NumPoints-NumDropPoints, 0, 0, 15, 6, Row, Col, Radius, StartPhi, EndPhi, PointOrder)
      * 显示找到的圆弧
      if (1)
          dev_set_color ('red')
          gen_circle_contour_xld (Circle, Row, Col, Radius, StartPhi, EndPhi, PointOrder, 1)
          dev_display (Circle)
      endif
  else
      Row := []
      Col := []
      Radius := []
  endif
  return ()


# Short Description: 通过两个圆环或者圆弧环寻找中间的圆
procedure FindCircle (Image: : TupleAnnular, Direction, NumPoints, NumDropPoints, 
    AmpThreshold, Smooth, Transition, Select: Row, Col, Radius)
  * 
  * 解析圆数据,根据长度判断是圆环还是圆弧环
  if (|TupleAnnular| == 6)
      * 由内向外时,中心点和半径以小圆为基准, 长度值为正值
      if (Direction == 'inner')
          if (TupleAnnular[2] < TupleAnnular[5])
              RowCircle := TupleAnnular[0]
              ColCircle := TupleAnnular[1]
              RadiusCircle := TupleAnnular[2]
              * 大小圆相减,得到查找长度范围
              Length := TupleAnnular[5]-TupleAnnular[2]
          else
              RowCircle := TupleAnnular[3]
              ColCircle := TupleAnnular[4]
              RadiusCircle := TupleAnnular[5]
              Length := TupleAnnular[2]-TupleAnnular[5]
          endif
          * 由外向内时,中心点和半径以大圆为基准, 长度值为负值
      else
          if (TupleAnnular[2] < TupleAnnular[5])
              RowCircle := TupleAnnular[3]
              ColCircle := TupleAnnular[4]
              RadiusCircle := TupleAnnular[5]
              * 大小圆相减,得到查找长度范围
              Length := TupleAnnular[2]-TupleAnnular[5]
          else
              RowCircle := TupleAnnular[0]
              ColCircle := TupleAnnular[1]
              RadiusCircle := TupleAnnular[2]
              * 大小圆相减,得到查找长度范围
              Length := TupleAnnular[5]-TupleAnnular[2]
          endif
      endif
      * 起始角度0,结束角度360
      FindCircle_Circle (Image, RowCircle, ColCircle, RadiusCircle, Length, rad(0), rad(360), NumPoints, NumDropPoints, AmpThreshold, Smooth, Transition, Select, Row, Col, Radius)
  elseif (|TupleAnnular| == 10)
      * 由内向外时,中心点和半径以小圆为基准, 长度值为正值
      if (Direction == 'inner')
          if (TupleAnnular[2] < TupleAnnular[7])
              RowCircle := TupleAnnular[0]
              ColCircle := TupleAnnular[1]
              RadiusCircle := TupleAnnular[2]
              * 大小圆相减,得到查找长度范围
              Length := TupleAnnular[7]-TupleAnnular[2]
              PhiStart := TupleAnnular[3]
              PhiExtent := TupleAnnular[4]
          else
              RowCircle := TupleAnnular[5]
              ColCircle := TupleAnnular[6]
              RadiusCircle := TupleAnnular[7]
              * 大小圆相减,得到查找长度范围
              Length := TupleAnnular[2]-TupleAnnular[7]
              PhiStart := TupleAnnular[8]
              PhiExtent := TupleAnnular[9]
          endif
          * 由外向内时,中心点和半径以大圆为基准, 长度值为负值
      else
          if (TupleAnnular[2] < TupleAnnular[7])
              RowCircle := TupleAnnular[5]
              ColCircle := TupleAnnular[6]
              RadiusCircle := TupleAnnular[7]
              * 大小圆相减,得到查找长度范围
              Length := TupleAnnular[2]-TupleAnnular[7]
              PhiStart := TupleAnnular[8]
              PhiExtent := TupleAnnular[9]
          else
              RowCircle := TupleAnnular[0]
              ColCircle := TupleAnnular[1]
              RadiusCircle := TupleAnnular[2]
              * 大小圆相减,得到查找长度范围
              Length := TupleAnnular[7]-TupleAnnular[2]
              PhiStart := TupleAnnular[3]
              PhiExtent := TupleAnnular[4]
          endif
      endif
      FindCircle_Circle (Image, RowCircle, ColCircle, RadiusCircle, Length, PhiStart, PhiExtent, NumPoints, NumDropPoints, AmpThreshold, Smooth, Transition, Select, Row, Col, Radius)
      * 
  endif
  * 
  return ()


# Short Description: 寻找制定图像区域的边缘点。
procedure FindPoint (Image: : MsrHandle, Smooth, AmpThreshold, Transition, Select: 
    Row, Col)
  * 
  * 取第一点或最后一点时,直接调用
  if (Select = 'first' or Select = 'last')
      measure_pos (Image, MsrHandle, Smooth, AmpThreshold, Transition, Select, Row, Col, Amplitude_Measure, Distance_Measure)
  elseif (Select = 'strongest')
      * 取最强点是,需要全部查找出来排序取最大值
      measure_pos (Image, MsrHandle, Smooth, AmpThreshold, Transition, 'all', Row_Measure, Col_Measure, Amplitude_Measure, Distance_Measure)
      tuple_length (Row_Measure, num)
      if (num > 0)
          tuple_sort_index (Amplitude_Measure, Indices)
          index := Indices[num -1]
          Row := Row_Measure[index]
          Col := Col_Measure[index]
      endif
  endif
  * 
  * 
  return ()


procedure dev_disp_message (: : String, CoordSystem, Row, Column, Color, Box: )
  * 
  * 获取当前活动窗口
  WindowHandle := -1
  dev_get_window (WindowHandle)
  if (WindowHandle != -1)
      disp_message (WindowHandle, String, CoordSystem, Row, Column, Color, Box)
  endif
  return ()


# Short Description: 通过输入图像查找模板获取转换的坐标矩阵。
procedure FindTemplete (Image: : ModelId, ModelData: ModelScore, FixTool)
  * 
  * 
  find_scaled_shape_model (Image, ModelId, rad(0), rad(360), 0.95, 1.05, 0.40, 1, 0.5, 'least_squares', [5,1], 0.75, ModelRow, ModelColumn, ModelAngle, ModelScale, ModelScore)
  if (|ModelScore| > 0)
      * 生成座标转换矩阵
      vector_angle_to_rigid (ModelData[0], ModelData[1], ModelData[2], ModelRow, ModelColumn, ModelAngle, FixTool)
      * 显示找到的轮廓
      if (1)
          dev_display_shape_matching_results (ModelId, 'red', ModelRow, ModelColumn, ModelAngle, 1, 1, 0)
  *         DetlaAngle := ModelAngle - InitAngle
      endif
      * 显示模板查找得分信息
      * 
      dev_disp_message ('Model Score is '+ ModelScore, 'window', 20, 20, 'green', 'false')
      * 
  else
  *     ModelScore := []
      dev_disp_message ('Model find fail !', 'window', 20, 20, 'red', 'true')
  endif
  return ()


# Local procedures 
# Short Description: 图像处理过程。
procedure T1_1 (Image: : Directory, ModelId, ModelData: TupleResult)
  TupleResult := -999
  * 
  dev_set_draw ('margin')
  gen_rectangle1 (ROI_0, 0, 0, 2748, 3840)
  dev_display (ROI_0)
  reduce_domain (Image, ROI_0, ImageReduced)
  * 进行模板查找
  FindTemplete (ImageReduced, ModelId, ModelData, Score, FixTool)
  if (|Score| > 0)
      * 读取第一个ROI,旋转矩形,带方向角度
      ReadRoiRectangle2 (Directory + '/Down.roi', RoiDataIn)
      * 根据模板查找的座标来转换ROI
      TranslateRoi (FixTool, RoiDataIn, RoiDataOut)
      * 查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
      * 阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
      FindLine (Image, RoiDataOut, 60, 30, 20, 10, 0.4, 'negative', 'first', RowBegin1, ColBegin1, RowEnd1, ColEnd1)
      if (|RowBegin1| = 0)
          TupleResult := -998
          dev_disp_message ('Error= '+ TupleResult+' TopLine Find Fail!', 'window', 60, 20, 'red', 'false')
          return ()
      endif
      angle_lx (RowEnd1, ColEnd1, RowBegin1, ColBegin1, Angle)
      Angle := deg(Angle)
      * 
      * 读取第二个ROI,旋转矩形,带方向角度
      ReadRoiRectangle2 (Directory + '/Right.roi', RoiDataIn)
      * 根据模板查找的座标来转换ROI
      TranslateRoi (FixTool, RoiDataIn, RoiDataOut)
      * 查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
      * 阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
      FindLine (Image, RoiDataOut, 60, 30, 20, 10, 0.4, 'negative', 'first', RowBegin2, ColBegin2, RowEnd2, ColEnd2)
      if (|RowBegin2| = 0)
          TupleResult := -997
          dev_disp_message ('Error= '+ TupleResult+' LeftLine Find Fail!', 'window', 60, 20, 'red', 'false')
          return ()
      endif
      angle_lx (RowEnd2, ColEnd2, RowBegin2, ColBegin2, Angle2)
      Angle2 := deg(Angle2)
      * 
      intersection_lines (RowBegin1, ColBegin1, RowEnd1, ColEnd1, RowBegin2, ColBegin2, RowEnd2, ColEnd2, Row, Col, IsOverlapping)
      * 
      if (|Row| = 0)
          TupleResult := -996
          dev_disp_message ('Error= '+ 'Center Find Fail!', 'window', 60, 20, 'red', 'false')
      else
          gen_cross_contour_xld (Cross, Row, Col, 60, 0.785398)
          dev_display (Cross)
          dev_disp_message ('Row= '+ Row, 'window', 40, 20, 'green', 'false')
          dev_disp_message ('Col= '+ Col, 'window', 60, 20, 'green', 'false')
          dev_disp_message ('Angle= '+ Angle, 'window', 80, 20, 'green', 'false')
          dev_disp_message ('Angle2= '+ Angle2, 'window', 100, 20, 'green', 'false')
          dev_disp_message ('Angle2-Angle= '+ (Angle2-Angle), 'window', 120, 20, 'green', 'false')
          * 
          TupleResult := [1, Row, Col, Angle]
      endif
  else
      * 模板查找失败
      TupleResult := -999
  endif
  * 
  return ()
  * 


# Short Description: 图像处理过程。
procedure T1_2 (Image: : Directory, ModelId, ModelData: TupleResult)
  * 先赋值，以免发生异常后读取非法内存
  * TupleResult := -999
  * 读取ROI,旋转矩形,带方向角度,判断举行区域面积,盖子没掀开时亮度高
  * ReadRoiRectangle2 (Directory + '/rect.roi', RoiDataIn)
  * 根据模板查找的座标来转换ROI
  * TranslateRoi (FixTool, RoiDataIn, RoiDataOut)
  * gen_rectangle2 (RectRegion, RoiDataOut[0], RoiDataOut[1], RoiDataOut[2], RoiDataOut[3], RoiDataOut[4])
  * dev_display (RectRegion)
  * maxArea := RoiDataOut[3]*RoiDataOut[4]*4
  * reduce_domain (Image, RectRegion, ImageReduced)
  * threshold (ImageReduced, Region1, 50, 255)
  * connection (Region1, ConnectedRegions)
  * select_shape (Region1, SelectedRegions, 'area', 'and', maxArea*0.8, maxArea*1.1)
  * count_obj (SelectedRegions, Number)
  * if (Number == 1)
  *     dev_disp_message ('cover is take ok!', 'window', 40, 20, 'green', 'false')
  *     TupleResult := [1]
  *     stop ()
  *     return ()
  * else
  *     TupleResult := -999
  *     dev_disp_message ('cover is take wrong!', 'window', 40, 20, 'red', 'false')
  * endif
  * 
  * return ()
  * 
  TupleResult := -999
  FindTemplete (Image, ModelId, ModelData, Score, FixTool)
  if (|Score| > 0)
      dev_disp_message ('cover is take ok!', 'window', 40, 20, 'green', 'false')
      TupleResult := [1]
  else
      * 模板查找失败
      dev_disp_message ('cover is take wrong!', 'window', 40, 20, 'red', 'false')
      TupleResult := -999
  endif
  return ()
  * 
  * 


# Short Description: 图像处理过程。
procedure T1_3 (Image: : Directory, ModelId, ModelData: TupleResult)
  * 先赋值，以免发生异常后读取非法内存
  TupleResult := -999
  * 
  dev_set_draw ('margin')
  * 
  gen_rectangle1 (ROI_0, 50.55, 50.447, 1569.19, 2058.33)
  gen_rectangle1 (ROI_0, 0, 0, 2748, 3840)
  dev_display (ROI_0)
  reduce_domain (Image, ROI_0, ImageReduced)
  * 
  FindTemplete (ImageReduced, ModelId, ModelData, Score, FixTool)
  if (Score >0)
      * 读取第一个ROI,旋转矩形,带方向角度
      ReadRoiRectangle2 (Directory + '/Bottom.roi', RoiDataIn)
      * 根据模板查找的座标来转换ROI
  *     hom_mat2d_identity (FixTool)
      TranslateRoi (FixTool, RoiDataIn, RoiDataOut)
      * 查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
      * 阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
      FindLine (Image, RoiDataOut, 60, 30, 20, 10, 0.4, 'negative', 'first', RowBegin1, ColBegin1, RowEnd1, ColEnd1)
      if (|RowBegin1| = 0)
          TupleResult := -998
          dev_disp_message ('Error= '+ TupleResult+' BottomLine Find Fail!', 'window', 60, 20, 'red', 'false')
          return ()
      endif
      angle_lx (RowEnd1, ColEnd1, RowBegin1, ColBegin1, Angle)
      Angle := deg(Angle)
      * 
      * 读取第二个ROI,旋转矩形,带方向角度
      ReadRoiRectangle2 (Directory + '/Left.roi', RoiDataIn)
      * 根据模板查找的座标来转换ROI
      TranslateRoi (FixTool, RoiDataIn, RoiDataOut)
      * 查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
      * 阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
      FindLine (Image, RoiDataOut, 60, 30, 20, 10, 0.4, 'positive', 'first', RowBegin2, ColBegin2, RowEnd2, ColEnd2)
      if (|RowBegin2| = 0)
          TupleResult := -997
          dev_disp_message ('Error= '+ TupleResult+' LeftLine Find Fail!', 'window', 60, 20, 'red', 'false')
          return ()
      endif
      angle_lx (RowEnd2, ColEnd2, RowBegin2, ColBegin2, Angle2)
      Angle2 := deg(Angle2)
      * 
      * 
      * 读取第二个ROI,旋转矩形,带方向角度
      ReadRoiRectangle2 (Directory + '/Right.roi', RoiDataIn)
      * 根据模板查找的座标来转换ROI
      TranslateRoi (FixTool, RoiDataIn, RoiDataOut)
      * 查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
      * 阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
      FindLine (Image, RoiDataOut, 60, 30, 20, 10, 0.4, 'negative', 'first', RowBegin3, ColBegin3, RowEnd3, ColEnd3)
      if (|RowBegin3| = 0)
          TupleResult := -996
          dev_disp_message ('Error= '+ TupleResult+' RightLine Find Fail!', 'window', 60, 20, 'red', 'false')
          return ()
      endif
      angle_lx (RowEnd3, ColEnd3, RowBegin3, ColBegin3, Angle3)
      Angle3 := deg(Angle3)
      * 
      intersection_lines (RowBegin1, ColBegin1, RowEnd1, ColEnd1, RowBegin2, ColBegin2, RowEnd2, ColEnd2, RowP1, ColP1, IsOverlapping)
      intersection_lines (RowBegin1, ColBegin1, RowEnd1, ColEnd1, RowBegin3, ColBegin3, RowEnd3, ColEnd3, RowP2, ColP2, IsOverlapping)
      Row := (RowP1+RowP2)/2
      Col := (ColP1+ColP2)/2
      if (|Row| = 0)
          TupleResult := -996
          dev_disp_message ('Error= '+ 'Center Find Fail!', 'window', 60, 20, 'red', 'false')
      else
          gen_cross_contour_xld (Cross, Row, Col, 60, 0.785398)
          dev_display (Cross)
          dev_disp_message ('Row= '+ Row, 'window', 40, 20, 'green', 'false')
          dev_disp_message ('Col= '+ Col, 'window', 60, 20, 'green', 'false')
          dev_disp_message ('Angle= '+ Angle, 'window', 80, 20, 'green', 'false')
          dev_disp_message ('Angle2= '+ Angle2, 'window', 100, 20, 'green', 'false')
          dev_disp_message ('Angle3= '+ Angle3, 'window', 120, 20, 'green', 'false')
          dev_disp_message ('Angle2-Angle= '+ (Angle2-Angle), 'window', 140, 20, 'green', 'false')
          dev_disp_message ('Angle3-Angle= '+ (Angle3-Angle), 'window', 160, 20, 'green', 'false')
          * 
          TupleResult := [1, Row, Col, Angle]
      endif
  else
      * 模板查找失败
      TupleResult := -999
  endif
  #* else
  * dev_disp_message ('No bottom Panle', 'window', 40, 20, 'green', 'false')
  * TupleResult := -1000
  #* endif
  return ()
  * 


# Short Description: 图像处理过程。
procedure T1_4 (Image: : Directory, ModelId, ModelData: TupleResult)
  * 先赋值，以免发生异常后读取非法内存
  TupleResult := -999
  * 
  dev_set_draw ('margin')
  * 
  gen_rectangle1 (ROI_0, 0, 0, 2748, 3840)
  dev_display (ROI_0)
  reduce_domain (Image, ROI_0, ImageReduced)
  * 
  FindTemplete (ImageReduced, ModelId, ModelData, Score, FixTool)
  if (|Score|>0)
      * 读取第一个ROI,圆环
      ReadRoiAnnularCircle (Directory +  '/T1_4.roi', RoiDataIn)
      * 根据模板查找的座标来转换ROI
      TranslateRoi (FixTool, RoiDataIn, RoiDataOut)
      * 查找圆,方向outer指定由外向内,以大圆半径为中心,100个点,可排除20个干扰点,阈值5,
      * 平滑系数0.4, 由白到黑,取第一点
      FindCircle (Image, RoiDataOut, 'inner', 100, 20, 5, 0.4, 'positive', 'first', Row, Col, Radius)
      * 
      if (|Row| = 0)
          TupleResult := -998
          return ()
      endif
      * 
      gen_cross_contour_xld (Cross, Row, Col, 60, 0.785398)
      * 
      dev_disp_message ('row= '+ Row, 'window', 40, 20, 'green', 'false')
      dev_disp_message ('col= '+ Col, 'window', 60, 20, 'green', 'false')
  *     dev_disp_message ('Angle= '+ Angle, 'window', 80, 20, 'green', 'false')
      dev_display (Cross)
      TupleResult := [1, Row, Col]
  else
      * 模板查找失败
      TupleResult := -999
  endif
  #* else
  * dev_disp_message ('No bottom Panle', 'window', 40, 20, 'green', 'false')
  * TupleResult := -1000
  #* endif
  return ()
  * 


# Short Description: 图像处理过程。
procedure T1_calib (Image: : Directory, ModelId, ModelData: TupleResult)
  TupleResult := -999
  * 
  dev_set_draw ('margin')
  gen_rectangle1 (ROI_0, 0, 0, 2748, 3840)
  dev_display (ROI_0)
  reduce_domain (Image, ROI_0, ImageReduced)
  * 进行模板查找
  FindTemplete (ImageReduced, ModelId, ModelData, Score, FixTool)
  if (|Score| > 0)
      * 读取第一个ROI,旋转矩形,带方向角度
      ReadRoiRectangle2 (Directory + '/Down.roi', RoiDataIn)
      * 根据模板查找的座标来转换ROI
      TranslateRoi (FixTool, RoiDataIn, RoiDataOut)
      * 查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
      * 阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
      FindLine (Image, RoiDataOut, 60, 30, 20, 10, 0.4, 'negative', 'first', RowBegin1, ColBegin1, RowEnd1, ColEnd1)
      if (|RowBegin1| = 0)
          TupleResult := -998
          dev_disp_message ('Error= '+ TupleResult+' TopLine Find Fail!', 'window', 60, 20, 'red', 'false')
          return ()
      endif
      angle_lx (RowEnd1, ColEnd1, RowBegin1, ColBegin1, Angle)
      Angle := deg(Angle)
      * 
      * 读取第二个ROI,旋转矩形,带方向角度
      ReadRoiRectangle2 (Directory + '/Right.roi', RoiDataIn)
      * 根据模板查找的座标来转换ROI
      TranslateRoi (FixTool, RoiDataIn, RoiDataOut)
      * 查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
      * 阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
      FindLine (Image, RoiDataOut, 60, 30, 20, 10, 0.4, 'negative', 'first', RowBegin2, ColBegin2, RowEnd2, ColEnd2)
      if (|RowBegin2| = 0)
          TupleResult := -997
          dev_disp_message ('Error= '+ TupleResult+' LeftLine Find Fail!', 'window', 60, 20, 'red', 'false')
          return ()
      endif
      angle_lx (RowEnd2, ColEnd2, RowBegin2, ColBegin2, Angle2)
      Angle2 := deg(Angle2)
      * 
      intersection_lines (RowBegin1, ColBegin1, RowEnd1, ColEnd1, RowBegin2, ColBegin2, RowEnd2, ColEnd2, Row, Col, IsOverlapping)
      * 
      if (|Row| = 0)
          TupleResult := -996
          dev_disp_message ('Error= '+ 'Center Find Fail!', 'window', 60, 20, 'red', 'false')
      else
          gen_cross_contour_xld (Cross, Row, Col, 60, 0.785398)
          dev_display (Cross)
          dev_disp_message ('Row= '+ Row, 'window', 40, 20, 'green', 'false')
          dev_disp_message ('Col= '+ Col, 'window', 60, 20, 'green', 'false')
          dev_disp_message ('Angle= '+ Angle, 'window', 80, 20, 'green', 'false')
          dev_disp_message ('Angle2= '+ Angle2, 'window', 100, 20, 'green', 'false')
          dev_disp_message ('Angle2-Angle= '+ (Angle2-Angle), 'window', 120, 20, 'green', 'false')
          * 
          TupleResult := [1, Row, Col, Angle]
      endif
  else
      * 模板查找失败
      TupleResult := -999
  endif
  * 
  return ()
  * 


procedure T1_calib2 (Image: : Directory, ModelId, ModelData: TupleResult)
  * 先赋值，以免发生异常后读取非法内存
  TupleResult := -999
  * 
  dev_set_draw ('margin')
  * 
  gen_rectangle1 (ROI_0, 0, 0, 2748, 3840)
  dev_display (ROI_0)
  reduce_domain (Image, ROI_0, ImageReduced)
  * 
  FindTemplete (ImageReduced, ModelId, ModelData, Score, FixTool)
  if (Score> 0.8)
      * 读取第一个ROI,圆环
      ReadRoiAnnularCircle (Directory +  '/T1_calib2.roi', RoiDataIn)
      * 根据模板查找的座标来转换ROI
      TranslateRoi (FixTool, RoiDataIn, RoiDataOut)
      * 查找圆,方向outer指定由外向内,以大圆半径为中心,100个点,可排除20个干扰点,阈值5,
      * 平滑系数0.4, 由白到黑,取第一点
      FindCircle (Image, RoiDataOut, 'inner', 100, 20, 5, 0.4, 'positive', 'first', Row, Col, Radius)
      * 
      if (|Row| = 0)
          TupleResult := -998
          return ()
      endif
      * 
      gen_cross_contour_xld (Cross, Row, Col, 60, 0.785398)
      * 
      dev_disp_message ('row= '+ Row, 'window', 40, 20, 'green', 'false')
      dev_disp_message ('col= '+ Col, 'window', 60, 20, 'green', 'false')
  *     dev_disp_message ('Angle= '+ Angle, 'window', 80, 20, 'green', 'false')
      dev_display (Cross)
      TupleResult := [1, Row, Col]
  else
      * 模板查找失败
      TupleResult := -999
  endif
  #* else
  * dev_disp_message ('No bottom Panle', 'window', 40, 20, 'green', 'false')
  * TupleResult := -1000
  #* endif
  return ()
  * 


# Short Description: 图像处理过程。
procedure T1_Others (Image: : Directory, ModelId, ModelData: TupleResult)
  TupleResult := -999
  * 
  dev_set_draw ('margin')
  gen_rectangle1 (ROI_0, 0, 0, 2748, 3840)
  dev_display (ROI_0)
  reduce_domain (Image, ROI_0, ImageReduced)
  * 进行模板查找
  FindTemplete (ImageReduced, ModelId, ModelData, Score, FixTool)
  if (|Score| > 0)
      * 读取第一个ROI,旋转矩形,带方向角度
      ReadRoiRectangle2 (Directory + '/Down.roi', RoiDataIn)
      * 根据模板查找的座标来转换ROI
      TranslateRoi (FixTool, RoiDataIn, RoiDataOut)
      * 查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
      * 阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
      FindLine (Image, RoiDataOut, 60, 30, 20, 10, 0.4, 'negative', 'first', RowBegin1, ColBegin1, RowEnd1, ColEnd1)
      if (|RowBegin1| = 0)
          TupleResult := -998
          dev_disp_message ('Error= '+ TupleResult+' TopLine Find Fail!', 'window', 60, 20, 'red', 'false')
          return ()
      endif
      angle_lx (RowEnd1, ColEnd1, RowBegin1, ColBegin1, Angle)
      Angle := deg(Angle)
      * 
      * 读取第二个ROI,旋转矩形,带方向角度
      ReadRoiRectangle2 (Directory + '/Right.roi', RoiDataIn)
      * 根据模板查找的座标来转换ROI
      TranslateRoi (FixTool, RoiDataIn, RoiDataOut)
      * 查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
      * 阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
      FindLine (Image, RoiDataOut, 60, 30, 20, 10, 0.4, 'negative', 'first', RowBegin2, ColBegin2, RowEnd2, ColEnd2)
      if (|RowBegin2| = 0)
          TupleResult := -997
          dev_disp_message ('Error= '+ TupleResult+' LeftLine Find Fail!', 'window', 60, 20, 'red', 'false')
          return ()
      endif
      angle_lx (RowEnd2, ColEnd2, RowBegin2, ColBegin2, Angle2)
      Angle2 := deg(Angle2)
      * 
      intersection_lines (RowBegin1, ColBegin1, RowEnd1, ColEnd1, RowBegin2, ColBegin2, RowEnd2, ColEnd2, Row, Col, IsOverlapping)
      * 
      if (|Row| = 0)
          TupleResult := -996
          dev_disp_message ('Error= '+ 'Center Find Fail!', 'window', 60, 20, 'red', 'false')
      else
          gen_cross_contour_xld (Cross, Row, Col, 60, 0.785398)
          dev_display (Cross)
          dev_disp_message ('Row= '+ Row, 'window', 40, 20, 'green', 'false')
          dev_disp_message ('Col= '+ Col, 'window', 60, 20, 'green', 'false')
          dev_disp_message ('Angle= '+ Angle, 'window', 80, 20, 'green', 'false')
          dev_disp_message ('Angle2= '+ Angle2, 'window', 100, 20, 'green', 'false')
          dev_disp_message ('Angle2-Angle= '+ (Angle2-Angle), 'window', 120, 20, 'green', 'false')
          * 
          TupleResult := [1, Row, Col, Angle]
      endif
  else
      * 模板查找失败
      TupleResult := -999
  endif
  * 
  return ()
  * 


# Main procedure 

  dev_open_window (0, 0, 800, 640, 'black', window)
  * 产品类型
  nSelect := 'T1_Others'
  * 如果选择其他模块，则
  SelectOther := 'T1_Others_1'
  Product := 'laser'
  if (nSelect=='T1_Others')
      SelectEnd := nSelect+'/'+SelectOther
  else
      SelectEnd := nSelect
  endif
  * 文件路径
  dir := 'E:/AutoFrame/Exe/VisionConfig/'
  * 产品路径
  dir := dir + Product +'/'+ SelectEnd
  * 初始化模板
  InitTemplete (dir, ModelId, ModelData)
  * 遍历文件夹，查找所有图片类型
  list_files (dir, ['files','recursive','follow_links'], ImageFiles)
  tuple_regexp_select (ImageFiles, ['\\.(tif|tiff|gif|bmp|jpg|jpeg|                       jp2|png|pcx|pgm|ppm|pbm|xwd|ima)$',                       'ignore_case'], ImageFiles)
  * 处理文件夹内所有图片
  for Index := 0 to |ImageFiles| - 1 by 1
      read_image (Image, ImageFiles[Index])
      dev_set_draw ('margin')
      get_image_size (Image, Width, Height)
      dev_display (Image)
      if (nSelect == 'T1_1')
          * 处理指定类型工件，找出关键点坐标并提取显示。
          T1_1 (Image, dir, ModelId, ModelData, TupleResult)
      elseif (nSelect == 'T1_2')
          T1_2 (Image, dir, ModelId, ModelData, TupleResult)
      elseif (nSelect == 'T1_3')
          T1_3 (Image, dir, ModelId, ModelData, TupleResult)
      elseif (nSelect == 'T1_4')
          T1_4 (Image, dir, ModelId, ModelData, TupleResult)
      elseif (nSelect == 'T1_Others')
          T1_Others (Image, dir, ModelId, ModelData, TupleResult)
      elseif (nSelect == 'T1_calib')
          T1_calib (Image, dir, ModelId, ModelData, TupleResult)
      elseif (nSelect == 'T1_calib2')
          T1_calib2 (Image, dir, ModelId, ModelData, TupleResult)
      endif
      * 等待一段时间s
      wait_seconds (0.1)
  endfor



